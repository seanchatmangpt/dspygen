{
    "sourceFile": "src/dspygen/rdddy/service_colony.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1724106946022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1724106958545,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,354 @@\n+\"\"\"\n+Actor System Module Documentation\n+\n+This module, service_colony.py, implements the ServiceColony class within the Reactive Domain-Driven Design (RDDDY) framework. It serves as the orchestrator for inhabitant lifecycle management, message passing, and system-wide coordination, ensuring that the principles of the Inhabitant model are adhered to in a domain-driven context.\n+\n+Overview:\n+The ServiceColony is responsible for creating, managing, and terminating inhabitants, facilitating asynchronous message passing between them, and maintaining system invariants. It is designed to operate seamlessly within an asynchronous programming environment, leveraging Python's asyncio library to handle concurrent operations efficiently.\n+\n+ServiceColony Multiline Calculus Notation (AMCN):\n+The behavior and operations within the ServiceColony are rigorously defined by the ServiceColony Multiline Calculus Notation (AMCN), ensuring a formalized approach to inhabitant management and message dissemination. The AMCN outlines the preconditions, actions, and postconditions for each operation within the system, integrating domain-specific assertions to align computational processes with the system's domain logic.\n+\n+1. Inhabitant Lifecycle Management\n+    Inhabitant Creation (ð´ð‘ð‘Ÿð‘’ð‘Žð‘¡ð‘’Acreate\\u200b):\n+    - Precondition (Pre Pre): Â¬âˆƒð‘Žâˆˆð´âˆ£ð‘Ž.ð‘–ð‘‘=ð‘–ð‘‘ð‘›ð‘’ð‘¤ Â¬âˆƒaâˆˆAâˆ£a.id=id new\\u200b\n+    - Action: ð‘ð‘Ÿð‘’ð‘Žð‘¡ð‘’ð´ð‘ð‘¡ð‘œð‘Ÿ(ð‘–ð‘‘ð‘›ð‘’ð‘¤,ð‘‡ð‘¦ð‘ð‘’)â†’ð‘Žð‘›ð‘’ð‘¤ createInhabitant(id new\\u200b,Type)â†’a new\\u200b\n+    - Postcondition (Post Post): âˆƒð‘Žâˆˆð´âˆ£ð‘Ž.ð‘–ð‘‘=ð‘–ð‘‘ð‘›ð‘’ð‘¤âˆ§ð‘Ž.ð‘¡ð‘¦ð‘ð‘’=ð‘‡ð‘¦ð‘ð‘’ âˆƒaâˆˆAâˆ£a.id=id new\\u200bâˆ§a.type=Type\n+\n+2. Message Dispatching\n+    Direct Message Sending (ð‘€ð‘ ð‘’ð‘›ð‘‘Msend\\u200b):\n+    - Precondition (Pre Pre): âˆƒð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡âˆˆð´ âˆƒa sender\\u200b,a recipient\\u200bâˆˆA\n+    - Action: ð‘ ð‘’ð‘›ð‘‘ð‘€ð‘’ð‘ ð‘ ð‘Žð‘”ð‘’(ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡,ð‘š) sendMessage(a sender\\u200b,a recipient\\u200b,m)\n+    - Postcondition (Post Post): ð‘šâˆˆð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡.ð‘šð‘Žð‘–ð‘™ð‘ð‘œð‘¥ mâˆˆa recipient\\u200b.mailbox\n+\n+    Broadcast Messaging (ð‘€ð‘ð‘Ÿð‘œð‘Žð‘‘ð‘ð‘Žð‘ ð‘¡ð‘€broadcast\\u200b):\n+    - Precondition (Pre Pre): âˆƒð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿâˆˆð´ âˆƒa sender\\u200bâˆˆA\n+    - Action: ð‘ð‘Ÿð‘œð‘Žð‘‘ð‘ð‘Žð‘ ð‘¡ð‘€ð‘’ð‘ ð‘ ð‘Žð‘”ð‘’(ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘š) broadcastMessage(a sender\\u200b,m)\n+    - Postcondition (Post Post): âˆ€ð‘Žâˆˆð´âˆ–{ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ},ð‘šâˆˆð‘Ž.ð‘šð‘Žð‘–ð‘™ð‘ð‘œð‘¥ âˆ€aâˆˆAâˆ–{a sender\\u200b},mâˆˆa.mailbox\n+\n+3. System Invariants and Domain Assertions\n+    Invariant Preservation (ð¼ð‘ð‘Ÿð‘’ð‘ ð‘’ð‘Ÿð‘£ð‘’Ipreserve\\u200b):\n+    - Invariant (ð¼ I): Î¦(ð´,ð‘€) Î¦(A,M)\n+    - Upon Action (ð‘Žð‘ð‘¡ð‘–ð‘œð‘›action): ð‘Žð‘ð‘¡ð‘–ð‘œð‘›(ð´,ð‘€)â†’ð´â€²,ð‘€â€² action(A,M)â†’Aâ€²,Mâ€²\n+    - Preservation (ð¼â€²Iâ€²): Î¦(ð´â€²,ð‘€â€²) Î¦(Aâ€²,Mâ€²)\n+    Domain-Specific Logic Integration (ð·ð‘–ð‘›ð‘¡ð‘’ð‘”ð‘Ÿð‘Žð‘¡ð‘’Dintegrate\\u200b):\n+    - Precondition (Pre ð· Pre D\\u200b): Î”(ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™) Î”(s global\\u200b)\n+    - Action and Domain Logic: ð‘ð‘’ð‘Ÿð‘“ð‘œð‘Ÿð‘šð´ð‘ð‘¡ð‘–ð‘œð‘›ð‘Šð‘–ð‘¡â„Žð·ð‘œð‘šð‘Žð‘–ð‘›ð¿ð‘œð‘”ð‘–ð‘(ð‘Ž,ð‘š,Î”)â†’ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™â€²,Î”â€² performActionWithDomainLogic(a,m,Î”)â†’s globalâ€²\\u200b,Î”â€²\n+    - Postcondition (Post ð· Post D\\u200b): Î”â€²(ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™â€²) Î”â€²(s globalâ€²\\u200b)\n+\n+Implementation Details:\n+The ServiceColony is implemented with a focus on modularity, scalability, and ease of use. It provides a high-level API for inhabitant management and message passing, abstracting away the complexities of asynchronous programming and inhabitant coordination. Developers can leverage the ServiceColony to build complex, responsive applications that are both computationally correct and domain-compliant.\n+\n+Usage:\n+To use the ServiceColony, instantiate it within your application and use its methods to create inhabitants and manage message passing. The system integrates seamlessly with the asyncio event loop, making it straightforward to incorporate into existing asynchronous applications.\n+\n+The service_colony.py module, guided by the AMCN, provides a robust foundation for developing inhabitant-based systems within the RDDDY framework, ensuring that applications are built with a solid architectural foundation that promotes maintainability, scalability, and domain-driven design principles.\n+\"\"\"\n+import asyncio\n+import json\n+from typing import TYPE_CHECKING, Optional, TypeVar, cast\n+from paho.mqtt import client as mclient\n+\n+import reactivex as rx\n+from loguru import logger\n+from reactivex import operators as ops\n+from reactivex.scheduler.eventloop import AsyncIOScheduler\n+\n+from dspygen.rdddy.base_message import BaseMessage, MessageFactory\n+\n+if TYPE_CHECKING:\n+    from dspygen.rdddy.base_inhabitantimport BaseInhabitant\n+\n+T = TypeVar(\"T\", bound=\"BaseInhabitant\")\n+\n+\n+class ServiceColony:\n+    \"\"\"Orchestrates inhabitant lifecycle management, message passing, and system-wide coordination within the RDDDY framework.\n+\n+    The ServiceColony class provides functionalities for creating, managing, and terminating inhabitants, facilitating asynchronous message passing between them, and maintaining system invariants.\n+\n+    Attributes:\n+        inhabitants (dict): A dictionary containing inhabitant IDs as keys and corresponding inhabitant instances as values.\n+        loop (asyncio.AbstractEventLoop): The asyncio event loop used for asynchronous operations.\n+        scheduler (AsyncIOScheduler): An asynchronous scheduler for controlling task execution.\n+        event_stream (Subject): A subject for publishing events within the inhabitant system.\n+\n+    Methods:\n+        inhabitant_of(inhabitant_class, **kwargs): Creates a new inhabitant instance and starts its mailbox processing loop.\n+        inhabitants_of(inhabitant_classes, **kwargs): Creates multiple inhabitant instances of different types.\n+        publish(message): Publishes a message to the inhabitant system for distribution.\n+        remove_inhabitant(inhabitant_id): Removes an inhabitant from the inhabitant system.\n+        send(inhabitant_id, message): Sends a message to a specific inhabitant within the system.\n+        wait_for_event(event_type): Waits for a specific event type to occur within the system.\n+\n+    Implementation Details:\n+    The ServiceColony class implements inhabitant management and message passing functionalities, abstracting away the\n+    complexities of asynchronous programming and inhabitant coordination. It integrates seamlessly with the asyncio\n+    event loop, ensuring efficient concurrent operations.\n+\n+    Usage:\n+    Instantiate an ServiceColony object within your application to manage inhabitants and coordinate message passing. Use its\n+    methods to create inhabitants, send messages, and wait for specific events within the system.\n+    \"\"\"\n+\n+    def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None, websocket_uri: str = None):\n+        \"\"\"Initializes the ServiceColony.\n+\n+        Args:\n+            loop (asyncio.AbstractEventLoop, optional): The asyncio event loop to be used for asynchronous operations.\n+                If not provided, the default event loop will be used.\n+            websocket_uri (str, optional): The URI of the WebSocket server to connect to.\n+\n+        Attributes:\n+            websocket_uri (str): The URI of the WebSocket server.\n+            websocket: The WebSocket connection object.\n+            inhabitants (dict): A dictionary containing inhabitant IDs as keys and corresponding inhabitant instances as values.\n+            loop (asyncio.AbstractEventLoop): The asyncio event loop used for asynchronous operations.\n+            scheduler (AsyncIOScheduler): An asynchronous scheduler for controlling task execution.\n+            event_stream (Subject): A subject for publishing events within the inhabitant system.\n+        \"\"\"\n+        self.mqtt_client = mqtt_client\n+        self.inhabitants: dict[int, \"BaseInhabitant\"] = {}\n+        self.loop = loop if loop is not None else asyncio.get_event_loop()\n+        self.scheduler = AsyncIOScheduler(loop=self.loop)\n+        self.event_stream = rx.subject.Subject()\n+\n+\n+    def on_connect(self, client, userdata, flags, reason_code, properties):\n+        print(\"Connected to MQTT Broker.\")\n+        client.subscribe(\"service_colony/publish\")  # Subscribe to the topic\n+\n+    def on_message(self, client, userdata, msg):\n+        print(f\"Received message from topic {msg.topic}: {msg.payload}\")\n+        # Deserialize the message payload into your internal message format\n+        payload_dict = json.loads(msg.payload)\n+        message = MessageFactory.create_message(payload_dict) # Implement this method based on your message class\n+        asyncio.run_coroutine_threadsafe(self.distribute_message(message), self.loop)\n+\n+    async def distribute_message(self, message):\n+        # Prevent republishing to MQTT by directly invoking the local distribution logic\n+        self.event_stream.on_next(message)\n+        inhabitants = list(self.inhabitants.values())\n+        for inhabitant in inhabitants:\n+            await self.send(inhabitant.inhabitant_id, message)\n+\n+    async def inhabitant_of(self, inhabitant_class, **kwargs) -> T:\n+        \"\"\"Creates a new inhabitant instance and starts its mailbox processing loop.\n+        T = TypeVar(\"T\", bound=\"Actor\")\n+\n+        Preconditions (Pre):\n+            - None\n+\n+        Transition (T):\n+            - Creates a new instance of the specified inhabitant class.\n+            - Initializes the inhabitant's mailbox.\n+            - Starts the processing loop for the inhabitant's mailbox, enabling asynchronous message handling.\n+\n+        Postconditions (Post):\n+            - A new inhabitant instance has been created and started successfully.\n+\n+        Args:\n+            inhabitant_class: The class of the inhabitant to be created.\n+            **kwargs: Additional keyword arguments to be passed to the inhabitant constructor.\n+\n+        Returns:\n+            T: The created inhabitant instance.\n+        \"\"\"\n+        inhabitant = inhabitant_class(self, **kwargs)\n+        self.inhabitants[inhabitant.inhabitant_id] = inhabitant\n+        await inhabitant.start(self.scheduler)\n+        logger.info(f\"Actor {inhabitant.inhabitant_id} started\")\n+        return inhabitant\n+\n+    async def inhabitants_of(self, inhabitant_classes, **kwargs) -> list[T]:\n+        \"\"\"Creates multiple inhabitant instances of different types and starts their mailbox processing loops.\n+        T = TypeVar(\"T\", bound=\"Actor\")\n+\n+        Preconditions (Pre):\n+            - None\n+\n+        Transition (T):\n+            - Creates new instances of the specified inhabitant classes.\n+            - Initializes the mailboxes for each inhabitant.\n+            - Starts the processing loop for each inhabitant's mailbox, enabling asynchronous message handling.\n+\n+        Postconditions (Post):\n+            - Multiple inhabitant instances have been created and started successfully.\n+\n+        Args:\n+            inhabitant_classes (List[Type]): A list of inhabitant classes to be instantiated.\n+            **kwargs: Additional keyword arguments to be passed to the inhabitant constructors.\n+\n+        Returns:\n+            List[T]: A list containing the created inhabitant instances.\n+        \"\"\"\n+        inhabitants = []\n+        for inhabitant_class in inhabitant_classes:\n+            inhabitant = await self.inhabitant_of(inhabitant_class, **kwargs)\n+            inhabitants.append(inhabitant)\n+        return inhabitants\n+\n+    async def publish(self, message: \"BaseMessage\"):\n+        \"\"\"Publishes a message to the inhabitant system for distribution.\n+\n+        Preconditions (Pre):\n+            - None\n+\n+        Transition (T):\n+            - Emits the message to the event stream of the inhabitant system.\n+            - Sends the message to each inhabitant within the system for processing.\n+\n+        Postconditions (Post):\n+            - The message has been published to the inhabitant system and processed by relevant inhabitants.\n+            - If the message is an instance of the base Message class, an error is raised.\n+\n+        Args:\n+            message (BaseMessage): The message to be published to the inhabitant system.\n+\n+        Raises:\n+            ValueError: If the base Message class is used directly.\n+        \"\"\"\n+        logger.debug(f\"Publishing message: {message}\")\n+\n+        if type(message) is BaseMessage:\n+            raise ValueError(\n+                \"The base Message class should not be used directly. Please use a subclass of Message.\"\n+            )\n+\n+        self.event_stream.on_next(message)\n+        inhabitants = list(self.inhabitants.values())\n+        for inhabitant in inhabitants:\n+            await self.send(inhabitant.inhabitant_id, message)\n+\n+        service_colony_topic = \"service_colony/publish\"\n+        # self.mqtt_client.publish(service_colony_topic, message.model_dump_json())\n+\n+    async def remove_inhabitant(self, inhabitant_id):\n+        \"\"\"Removes an inhabitant from the inhabitant system.\n+\n+        Preconditions (Pre):\n+            - The inhabitant ID must exist in the inhabitant system.\n+\n+        Transition (T):\n+            - Removes the inhabitant with the specified ID from the inhabitant system.\n+\n+        Postconditions (Post):\n+            - The inhabitant has been successfully removed from the inhabitant system.\n+\n+        Args:\n+            inhabitant_id: The ID of the inhabitant to be removed.\n+        \"\"\"\n+        inhabitant = self.inhabitants.pop(inhabitant_id, None)\n+        if inhabitant:\n+            logger.debug(f\"Removing inhabitant {inhabitant_id}\")\n+        else:\n+            logger.debug(f\"Actor {inhabitant_id} not found for removal\")\n+        logger.debug(f\"Current inhabitants count: {len(self.inhabitants)}\")\n+\n+    async def send(self, inhabitant_id: int, message: \"BaseMessage\"):\n+        \"\"\"Sends a message to a specific inhabitant within the inhabitant system.\n+\n+        Preconditions (Pre):\n+            - The inhabitant ID must exist in the inhabitant system.\n+            - The message must be an instance of the Message class.\n+\n+        Transition (T):\n+            - Delivers the message to the specified inhabitant's mailbox for processing.\n+\n+        Postconditions (Post):\n+            - The message has been successfully sent to the specified inhabitant for processing.\n+\n+        Args:\n+            inhabitant_id (int): The ID of the target inhabitant.\n+            message (BaseMessage): The message to be sent to the target inhabitant.\n+        \"\"\"\n+        # logger.debug(f\"Sending message {message} to inhabitant {inhabitant_id}\")\n+        inhabitant = self.inhabitants.get(inhabitant_id)\n+        if inhabitant:\n+            inhabitant.mailbox.on_next(message)\n+            await asyncio.sleep(0)\n+        else:\n+            logger.debug(f\"Actor {inhabitant_id} not found.\")\n+\n+    async def wait_for_message(self, message_type: type) -> \"BaseMessage\":\n+        \"\"\"Waits for a message of a specific type to be published to the inhabitant system.\n+\n+        Preconditions (Pre):\n+            - None\n+\n+        Transition (T):\n+            - Subscribes to the event stream of the inhabitant system.\n+            - Waits until a message of the specified type is published.\n+\n+        Postconditions (Post):\n+            - A message of the specified type has been received from the inhabitant system.\n+\n+        Args:\n+            message_type (type): The type of message to wait for.\n+\n+        Returns:\n+            asyncio.Future: A future object representing the awaited message.\n+        \"\"\"\n+        loop = asyncio.get_event_loop()\n+        future = loop.create_future()\n+\n+        def on_next(msg):\n+            if isinstance(msg, message_type):\n+                future.set_result(msg)\n+                subscription.dispose()\n+\n+        subscription = self.event_stream.pipe(\n+            ops.filter(lambda msg: isinstance(msg, message_type))\n+        ).subscribe(on_next)\n+\n+        return await future\n+\n+    def __getitem__(self, inhabitant_id) -> T:\n+        \"\"\"Retrieves an inhabitant by its ID from the inhabitant system.\n+\n+        Preconditions (Pre):\n+            - The inhabitant ID must exist in the inhabitant system.\n+\n+        Transition (T):\n+            - Retrieves the inhabitant with the specified ID from the inhabitant system.\n+\n+        Postconditions (Post):\n+            - The inhabitant with the specified ID has been successfully retrieved from the inhabitant system.\n+\n+        Args:\n+            inhabitant_id: The ID of the inhabitant to retrieve.\n+\n+        Returns:\n+            BaseInhabitant: The inhabitant object corresponding to the specified ID.\n+        \"\"\"\n+        return cast(T, self.inhabitants.get(inhabitant_id))\n+\n+\n+    async def shutdown(self):\n+        \"\"\"Shuts down the inhabitant system and terminates all inhabitants.\n+\n+        Preconditions (Pre):\n+            - None\n+\n+        Transition (T):\n+            - Terminates all inhabitants within the inhabitant system.\n+            - Closes the event stream and scheduler.\n+\n+        Postconditions (Post):\n+            - The inhabitant system has been successfully shut down.\n+        \"\"\"\n+        # self.mqtt_client.loop_stop()\n+        # self.mqtt_client.disconnect()\n+        logger.debug(\"Actor system shutdown complete.\")\n+\n+\n+import asyncio\n+\n+\n+async def main():\n+    print(\"main\")\n+    # await\n+\n+\n+if __name__ == \"__main__\":\n+    asyncio.run(main())\n"
                },
                {
                    "date": 1724106975138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -215,14 +215,14 @@\n             raise ValueError(\n                 \"The base Message class should not be used directly. Please use a subclass of Message.\"\n             )\n \n+        if self.websocket:\n+            await self.websocket.send(json.dumps(message.model_dump_json()))\n         self.event_stream.on_next(message)\n         inhabitants = list(self.inhabitants.values())\n         for inhabitant in inhabitants:\n             await self.send(inhabitant.inhabitant_id, message)\n-\n-        service_colony_topic = \"service_colony/publish\"\n         # self.mqtt_client.publish(service_colony_topic, message.model_dump_json())\n \n     async def remove_inhabitant(self, inhabitant_id):\n         \"\"\"Removes an inhabitant from the inhabitant system.\n"
                },
                {
                    "date": 1724106985134,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -106,9 +106,10 @@\n             loop (asyncio.AbstractEventLoop): The asyncio event loop used for asynchronous operations.\n             scheduler (AsyncIOScheduler): An asynchronous scheduler for controlling task execution.\n             event_stream (Subject): A subject for publishing events within the inhabitant system.\n         \"\"\"\n-        self.mqtt_client = mqtt_client\n+        self.websocket_uri = websocket_uri\n+        self.websocket = None\n         self.inhabitants: dict[int, \"BaseInhabitant\"] = {}\n         self.loop = loop if loop is not None else asyncio.get_event_loop()\n         self.scheduler = AsyncIOScheduler(loop=self.loop)\n         self.event_stream = rx.subject.Subject()\n@@ -220,9 +221,8 @@\n         self.event_stream.on_next(message)\n         inhabitants = list(self.inhabitants.values())\n         for inhabitant in inhabitants:\n             await self.send(inhabitant.inhabitant_id, message)\n-        # self.mqtt_client.publish(service_colony_topic, message.model_dump_json())\n \n     async def remove_inhabitant(self, inhabitant_id):\n         \"\"\"Removes an inhabitant from the inhabitant system.\n \n@@ -351,355 +351,4 @@\n \n \n if __name__ == \"__main__\":\n     asyncio.run(main())\n-\"\"\"\n-Actor System Module Documentation\n-\n-This module, service_colony.py, implements the ServiceColony class within the Reactive Domain-Driven Design (RDDDY) framework. It serves as the orchestrator for inhabitant lifecycle management, message passing, and system-wide coordination, ensuring that the principles of the Inhabitant model are adhered to in a domain-driven context.\n-\n-Overview:\n-The ServiceColony is responsible for creating, managing, and terminating inhabitants, facilitating asynchronous message passing between them, and maintaining system invariants. It is designed to operate seamlessly within an asynchronous programming environment, leveraging Python's asyncio library to handle concurrent operations efficiently.\n-\n-ServiceColony Multiline Calculus Notation (AMCN):\n-The behavior and operations within the ServiceColony are rigorously defined by the ServiceColony Multiline Calculus Notation (AMCN), ensuring a formalized approach to inhabitant management and message dissemination. The AMCN outlines the preconditions, actions, and postconditions for each operation within the system, integrating domain-specific assertions to align computational processes with the system's domain logic.\n-\n-1. Inhabitant Lifecycle Management\n-    Inhabitant Creation (ð´ð‘ð‘Ÿð‘’ð‘Žð‘¡ð‘’Acreate\\u200b):\n-    - Precondition (Pre Pre): Â¬âˆƒð‘Žâˆˆð´âˆ£ð‘Ž.ð‘–ð‘‘=ð‘–ð‘‘ð‘›ð‘’ð‘¤ Â¬âˆƒaâˆˆAâˆ£a.id=id new\\u200b\n-    - Action: ð‘ð‘Ÿð‘’ð‘Žð‘¡ð‘’ð´ð‘ð‘¡ð‘œð‘Ÿ(ð‘–ð‘‘ð‘›ð‘’ð‘¤,ð‘‡ð‘¦ð‘ð‘’)â†’ð‘Žð‘›ð‘’ð‘¤ createInhabitant(id new\\u200b,Type)â†’a new\\u200b\n-    - Postcondition (Post Post): âˆƒð‘Žâˆˆð´âˆ£ð‘Ž.ð‘–ð‘‘=ð‘–ð‘‘ð‘›ð‘’ð‘¤âˆ§ð‘Ž.ð‘¡ð‘¦ð‘ð‘’=ð‘‡ð‘¦ð‘ð‘’ âˆƒaâˆˆAâˆ£a.id=id new\\u200bâˆ§a.type=Type\n-\n-2. Message Dispatching\n-    Direct Message Sending (ð‘€ð‘ ð‘’ð‘›ð‘‘Msend\\u200b):\n-    - Precondition (Pre Pre): âˆƒð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡âˆˆð´ âˆƒa sender\\u200b,a recipient\\u200bâˆˆA\n-    - Action: ð‘ ð‘’ð‘›ð‘‘ð‘€ð‘’ð‘ ð‘ ð‘Žð‘”ð‘’(ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡,ð‘š) sendMessage(a sender\\u200b,a recipient\\u200b,m)\n-    - Postcondition (Post Post): ð‘šâˆˆð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡.ð‘šð‘Žð‘–ð‘™ð‘ð‘œð‘¥ mâˆˆa recipient\\u200b.mailbox\n-\n-    Broadcast Messaging (ð‘€ð‘ð‘Ÿð‘œð‘Žð‘‘ð‘ð‘Žð‘ ð‘¡ð‘€broadcast\\u200b):\n-    - Precondition (Pre Pre): âˆƒð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿâˆˆð´ âˆƒa sender\\u200bâˆˆA\n-    - Action: ð‘ð‘Ÿð‘œð‘Žð‘‘ð‘ð‘Žð‘ ð‘¡ð‘€ð‘’ð‘ ð‘ ð‘Žð‘”ð‘’(ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘š) broadcastMessage(a sender\\u200b,m)\n-    - Postcondition (Post Post): âˆ€ð‘Žâˆˆð´âˆ–{ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ},ð‘šâˆˆð‘Ž.ð‘šð‘Žð‘–ð‘™ð‘ð‘œð‘¥ âˆ€aâˆˆAâˆ–{a sender\\u200b},mâˆˆa.mailbox\n-\n-3. System Invariants and Domain Assertions\n-    Invariant Preservation (ð¼ð‘ð‘Ÿð‘’ð‘ ð‘’ð‘Ÿð‘£ð‘’Ipreserve\\u200b):\n-    - Invariant (ð¼ I): Î¦(ð´,ð‘€) Î¦(A,M)\n-    - Upon Action (ð‘Žð‘ð‘¡ð‘–ð‘œð‘›action): ð‘Žð‘ð‘¡ð‘–ð‘œð‘›(ð´,ð‘€)â†’ð´â€²,ð‘€â€² action(A,M)â†’Aâ€²,Mâ€²\n-    - Preservation (ð¼â€²Iâ€²): Î¦(ð´â€²,ð‘€â€²) Î¦(Aâ€²,Mâ€²)\n-    Domain-Specific Logic Integration (ð·ð‘–ð‘›ð‘¡ð‘’ð‘”ð‘Ÿð‘Žð‘¡ð‘’Dintegrate\\u200b):\n-    - Precondition (Pre ð· Pre D\\u200b): Î”(ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™) Î”(s global\\u200b)\n-    - Action and Domain Logic: ð‘ð‘’ð‘Ÿð‘“ð‘œð‘Ÿð‘šð´ð‘ð‘¡ð‘–ð‘œð‘›ð‘Šð‘–ð‘¡â„Žð·ð‘œð‘šð‘Žð‘–ð‘›ð¿ð‘œð‘”ð‘–ð‘(ð‘Ž,ð‘š,Î”)â†’ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™â€²,Î”â€² performActionWithDomainLogic(a,m,Î”)â†’s globalâ€²\\u200b,Î”â€²\n-    - Postcondition (Post ð· Post D\\u200b): Î”â€²(ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™â€²) Î”â€²(s globalâ€²\\u200b)\n-\n-Implementation Details:\n-The ServiceColony is implemented with a focus on modularity, scalability, and ease of use. It provides a high-level API for inhabitant management and message passing, abstracting away the complexities of asynchronous programming and inhabitant coordination. Developers can leverage the ServiceColony to build complex, responsive applications that are both computationally correct and domain-compliant.\n-\n-Usage:\n-To use the ServiceColony, instantiate it within your application and use its methods to create inhabitants and manage message passing. The system integrates seamlessly with the asyncio event loop, making it straightforward to incorporate into existing asynchronous applications.\n-\n-The service_colony.py module, guided by the AMCN, provides a robust foundation for developing inhabitant-based systems within the RDDDY framework, ensuring that applications are built with a solid architectural foundation that promotes maintainability, scalability, and domain-driven design principles.\n-\"\"\"\n-import asyncio\n-import json\n-from typing import TYPE_CHECKING, Optional, TypeVar, cast\n-from paho.mqtt import client as mclient\n-\n-import reactivex as rx\n-from loguru import logger\n-from reactivex import operators as ops\n-from reactivex.scheduler.eventloop import AsyncIOScheduler\n-\n-from dspygen.rdddy.base_message import BaseMessage, MessageFactory\n-\n-if TYPE_CHECKING:\n-    from dspygen.rdddy.base_inhabitantimport BaseInhabitant\n-\n-T = TypeVar(\"T\", bound=\"BaseInhabitant\")\n-\n-\n-class ServiceColony:\n-    \"\"\"Orchestrates inhabitant lifecycle management, message passing, and system-wide coordination within the RDDDY framework.\n-\n-    The ServiceColony class provides functionalities for creating, managing, and terminating inhabitants, facilitating asynchronous message passing between them, and maintaining system invariants.\n-\n-    Attributes:\n-        inhabitants (dict): A dictionary containing inhabitant IDs as keys and corresponding inhabitant instances as values.\n-        loop (asyncio.AbstractEventLoop): The asyncio event loop used for asynchronous operations.\n-        scheduler (AsyncIOScheduler): An asynchronous scheduler for controlling task execution.\n-        event_stream (Subject): A subject for publishing events within the inhabitant system.\n-\n-    Methods:\n-        inhabitant_of(inhabitant_class, **kwargs): Creates a new inhabitant instance and starts its mailbox processing loop.\n-        inhabitants_of(inhabitant_classes, **kwargs): Creates multiple inhabitant instances of different types.\n-        publish(message): Publishes a message to the inhabitant system for distribution.\n-        remove_inhabitant(inhabitant_id): Removes an inhabitant from the inhabitant system.\n-        send(inhabitant_id, message): Sends a message to a specific inhabitant within the system.\n-        wait_for_event(event_type): Waits for a specific event type to occur within the system.\n-\n-    Implementation Details:\n-    The ServiceColony class implements inhabitant management and message passing functionalities, abstracting away the\n-    complexities of asynchronous programming and inhabitant coordination. It integrates seamlessly with the asyncio\n-    event loop, ensuring efficient concurrent operations.\n-\n-    Usage:\n-    Instantiate an ServiceColony object within your application to manage inhabitants and coordinate message passing. Use its\n-    methods to create inhabitants, send messages, and wait for specific events within the system.\n-    \"\"\"\n-\n-    def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None, mqtt_client: mclient = None):\n-        \"\"\"Initializes the ServiceColony.\n-\n-        Args:\n-            loop (asyncio.AbstractEventLoop, optional): The asyncio event loop to be used for asynchronous operations.\n-                If not provided, the default event loop will be used.\n-\n-        Attributes:\n-            inhabitants (dict): A dictionary containing inhabitant IDs as keys and corresponding inhabitant instances as values.\n-            loop (asyncio.AbstractEventLoop): The asyncio event loop used for asynchronous operations.\n-            scheduler (AsyncIOScheduler): An asynchronous scheduler for controlling task execution.\n-            event_stream (Subject): A subject for publishing events within the inhabitant system.\n-        \"\"\"\n-        self.mqtt_client = mqtt_client\n-        self.inhabitants: dict[int, \"BaseInhabitant\"] = {}\n-        self.loop = loop if loop is not None else asyncio.get_event_loop()\n-        self.scheduler = AsyncIOScheduler(loop=self.loop)\n-        self.event_stream = rx.subject.Subject()\n-\n-\n-    def on_connect(self, client, userdata, flags, reason_code, properties):\n-        print(\"Connected to MQTT Broker.\")\n-        client.subscribe(\"service_colony/publish\")  # Subscribe to the topic\n-\n-    def on_message(self, client, userdata, msg):\n-        print(f\"Received message from topic {msg.topic}: {msg.payload}\")\n-        # Deserialize the message payload into your internal message format\n-        payload_dict = json.loads(msg.payload)\n-        message = MessageFactory.create_message(payload_dict) # Implement this method based on your message class\n-        asyncio.run_coroutine_threadsafe(self.distribute_message(message), self.loop)\n-\n-    async def distribute_message(self, message):\n-        # Prevent republishing to MQTT by directly invoking the local distribution logic\n-        self.event_stream.on_next(message)\n-        inhabitants = list(self.inhabitants.values())\n-        for inhabitant in inhabitants:\n-            await self.send(inhabitant.inhabitant_id, message)\n-\n-    async def inhabitant_of(self, inhabitant_class, **kwargs) -> T:\n-        \"\"\"Creates a new inhabitant instance and starts its mailbox processing loop.\n-        T = TypeVar(\"T\", bound=\"Actor\")\n-\n-        Preconditions (Pre):\n-            - None\n-\n-        Transition (T):\n-            - Creates a new instance of the specified inhabitant class.\n-            - Initializes the inhabitant's mailbox.\n-            - Starts the processing loop for the inhabitant's mailbox, enabling asynchronous message handling.\n-\n-        Postconditions (Post):\n-            - A new inhabitant instance has been created and started successfully.\n-\n-        Args:\n-            inhabitant_class: The class of the inhabitant to be created.\n-            **kwargs: Additional keyword arguments to be passed to the inhabitant constructor.\n-\n-        Returns:\n-            T: The created inhabitant instance.\n-        \"\"\"\n-        inhabitant = inhabitant_class(self, **kwargs)\n-        self.inhabitants[inhabitant.inhabitant_id] = inhabitant\n-        await inhabitant.start(self.scheduler)\n-        logger.info(f\"Actor {inhabitant.inhabitant_id} started\")\n-        return inhabitant\n-\n-    async def inhabitants_of(self, inhabitant_classes, **kwargs) -> list[T]:\n-        \"\"\"Creates multiple inhabitant instances of different types and starts their mailbox processing loops.\n-        T = TypeVar(\"T\", bound=\"Actor\")\n-\n-        Preconditions (Pre):\n-            - None\n-\n-        Transition (T):\n-            - Creates new instances of the specified inhabitant classes.\n-            - Initializes the mailboxes for each inhabitant.\n-            - Starts the processing loop for each inhabitant's mailbox, enabling asynchronous message handling.\n-\n-        Postconditions (Post):\n-            - Multiple inhabitant instances have been created and started successfully.\n-\n-        Args:\n-            inhabitant_classes (List[Type]): A list of inhabitant classes to be instantiated.\n-            **kwargs: Additional keyword arguments to be passed to the inhabitant constructors.\n-\n-        Returns:\n-            List[T]: A list containing the created inhabitant instances.\n-        \"\"\"\n-        inhabitants = []\n-        for inhabitant_class in inhabitant_classes:\n-            inhabitant = await self.inhabitant_of(inhabitant_class, **kwargs)\n-            inhabitants.append(inhabitant)\n-        return inhabitants\n-\n-    async def publish(self, message: \"BaseMessage\"):\n-        \"\"\"Publishes a message to the inhabitant system for distribution.\n-\n-        Preconditions (Pre):\n-            - None\n-\n-        Transition (T):\n-            - Emits the message to the event stream of the inhabitant system.\n-            - Sends the message to each inhabitant within the system for processing.\n-\n-        Postconditions (Post):\n-            - The message has been published to the inhabitant system and processed by relevant inhabitants.\n-            - If the message is an instance of the base Message class, an error is raised.\n-\n-        Args:\n-            message (BaseMessage): The message to be published to the inhabitant system.\n-\n-        Raises:\n-            ValueError: If the base Message class is used directly.\n-        \"\"\"\n-        logger.debug(f\"Publishing message: {message}\")\n-\n-        if type(message) is BaseMessage:\n-            raise ValueError(\n-                \"The base Message class should not be used directly. Please use a subclass of Message.\"\n-            )\n-\n-        self.event_stream.on_next(message)\n-        inhabitants = list(self.inhabitants.values())\n-        for inhabitant in inhabitants:\n-            await self.send(inhabitant.inhabitant_id, message)\n-\n-        service_colony_topic = \"service_colony/publish\"\n-        # self.mqtt_client.publish(service_colony_topic, message.model_dump_json())\n-\n-    async def remove_inhabitant(self, inhabitant_id):\n-        \"\"\"Removes an inhabitant from the inhabitant system.\n-\n-        Preconditions (Pre):\n-            - The inhabitant ID must exist in the inhabitant system.\n-\n-        Transition (T):\n-            - Removes the inhabitant with the specified ID from the inhabitant system.\n-\n-        Postconditions (Post):\n-            - The inhabitant has been successfully removed from the inhabitant system.\n-\n-        Args:\n-            inhabitant_id: The ID of the inhabitant to be removed.\n-        \"\"\"\n-        inhabitant = self.inhabitants.pop(inhabitant_id, None)\n-        if inhabitant:\n-            logger.debug(f\"Removing inhabitant {inhabitant_id}\")\n-        else:\n-            logger.debug(f\"Actor {inhabitant_id} not found for removal\")\n-        logger.debug(f\"Current inhabitants count: {len(self.inhabitants)}\")\n-\n-    async def send(self, inhabitant_id: int, message: \"BaseMessage\"):\n-        \"\"\"Sends a message to a specific inhabitant within the inhabitant system.\n-\n-        Preconditions (Pre):\n-            - The inhabitant ID must exist in the inhabitant system.\n-            - The message must be an instance of the Message class.\n-\n-        Transition (T):\n-            - Delivers the message to the specified inhabitant's mailbox for processing.\n-\n-        Postconditions (Post):\n-            - The message has been successfully sent to the specified inhabitant for processing.\n-\n-        Args:\n-            inhabitant_id (int): The ID of the target inhabitant.\n-            message (BaseMessage): The message to be sent to the target inhabitant.\n-        \"\"\"\n-        # logger.debug(f\"Sending message {message} to inhabitant {inhabitant_id}\")\n-        inhabitant = self.inhabitants.get(inhabitant_id)\n-        if inhabitant:\n-            inhabitant.mailbox.on_next(message)\n-            await asyncio.sleep(0)\n-        else:\n-            logger.debug(f\"Actor {inhabitant_id} not found.\")\n-\n-    async def wait_for_message(self, message_type: type) -> \"BaseMessage\":\n-        \"\"\"Waits for a message of a specific type to be published to the inhabitant system.\n-\n-        Preconditions (Pre):\n-            - None\n-\n-        Transition (T):\n-            - Subscribes to the event stream of the inhabitant system.\n-            - Waits until a message of the specified type is published.\n-\n-        Postconditions (Post):\n-            - A message of the specified type has been received from the inhabitant system.\n-\n-        Args:\n-            message_type (type): The type of message to wait for.\n-\n-        Returns:\n-            asyncio.Future: A future object representing the awaited message.\n-        \"\"\"\n-        loop = asyncio.get_event_loop()\n-        future = loop.create_future()\n-\n-        def on_next(msg):\n-            if isinstance(msg, message_type):\n-                future.set_result(msg)\n-                subscription.dispose()\n-\n-        subscription = self.event_stream.pipe(\n-            ops.filter(lambda msg: isinstance(msg, message_type))\n-        ).subscribe(on_next)\n-\n-        return await future\n-\n-    def __getitem__(self, inhabitant_id) -> T:\n-        \"\"\"Retrieves an inhabitant by its ID from the inhabitant system.\n-\n-        Preconditions (Pre):\n-            - The inhabitant ID must exist in the inhabitant system.\n-\n-        Transition (T):\n-            - Retrieves the inhabitant with the specified ID from the inhabitant system.\n-\n-        Postconditions (Post):\n-            - The inhabitant with the specified ID has been successfully retrieved from the inhabitant system.\n-\n-        Args:\n-            inhabitant_id: The ID of the inhabitant to retrieve.\n-\n-        Returns:\n-            BaseInhabitant: The inhabitant object corresponding to the specified ID.\n-        \"\"\"\n-        return cast(T, self.inhabitants.get(inhabitant_id))\n-\n-\n-    async def shutdown(self):\n-        \"\"\"Shuts down the inhabitant system and terminates all inhabitants.\n-\n-        Preconditions (Pre):\n-            - None\n-\n-        Transition (T):\n-            - Terminates all inhabitants within the inhabitant system.\n-            - Closes the event stream and scheduler.\n-\n-        Postconditions (Post):\n-            - The inhabitant system has been successfully shut down.\n-        \"\"\"\n-        # self.mqtt_client.loop_stop()\n-        # self.mqtt_client.disconnect()\n-        logger.debug(\"Actor system shutdown complete.\")\n-\n-\n-import asyncio\n-\n-\n-async def main():\n-    print(\"main\")\n-    # await\n-\n-\n-if __name__ == \"__main__\":\n-    asyncio.run(main())\n"
                },
                {
                    "date": 1724106993446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,354 @@\n+\"\"\"\n+Actor System Module Documentation\n+\n+This module, service_colony.py, implements the ServiceColony class within the Reactive Domain-Driven Design (RDDDY) framework. It serves as the orchestrator for inhabitant lifecycle management, message passing, and system-wide coordination, ensuring that the principles of the Inhabitant model are adhered to in a domain-driven context.\n+\n+Overview:\n+The ServiceColony is responsible for creating, managing, and terminating inhabitants, facilitating asynchronous message passing between them, and maintaining system invariants. It is designed to operate seamlessly within an asynchronous programming environment, leveraging Python's asyncio library to handle concurrent operations efficiently.\n+\n+ServiceColony Multiline Calculus Notation (AMCN):\n+The behavior and operations within the ServiceColony are rigorously defined by the ServiceColony Multiline Calculus Notation (AMCN), ensuring a formalized approach to inhabitant management and message dissemination. The AMCN outlines the preconditions, actions, and postconditions for each operation within the system, integrating domain-specific assertions to align computational processes with the system's domain logic.\n+\n+1. Inhabitant Lifecycle Management\n+    Inhabitant Creation (ð´ð‘ð‘Ÿð‘’ð‘Žð‘¡ð‘’Acreate\\u200b):\n+    - Precondition (Pre Pre): Â¬âˆƒð‘Žâˆˆð´âˆ£ð‘Ž.ð‘–ð‘‘=ð‘–ð‘‘ð‘›ð‘’ð‘¤ Â¬âˆƒaâˆˆAâˆ£a.id=id new\\u200b\n+    - Action: ð‘ð‘Ÿð‘’ð‘Žð‘¡ð‘’ð´ð‘ð‘¡ð‘œð‘Ÿ(ð‘–ð‘‘ð‘›ð‘’ð‘¤,ð‘‡ð‘¦ð‘ð‘’)â†’ð‘Žð‘›ð‘’ð‘¤ createInhabitant(id new\\u200b,Type)â†’a new\\u200b\n+    - Postcondition (Post Post): âˆƒð‘Žâˆˆð´âˆ£ð‘Ž.ð‘–ð‘‘=ð‘–ð‘‘ð‘›ð‘’ð‘¤âˆ§ð‘Ž.ð‘¡ð‘¦ð‘ð‘’=ð‘‡ð‘¦ð‘ð‘’ âˆƒaâˆˆAâˆ£a.id=id new\\u200bâˆ§a.type=Type\n+\n+2. Message Dispatching\n+    Direct Message Sending (ð‘€ð‘ ð‘’ð‘›ð‘‘Msend\\u200b):\n+    - Precondition (Pre Pre): âˆƒð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡âˆˆð´ âˆƒa sender\\u200b,a recipient\\u200bâˆˆA\n+    - Action: ð‘ ð‘’ð‘›ð‘‘ð‘€ð‘’ð‘ ð‘ ð‘Žð‘”ð‘’(ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡,ð‘š) sendMessage(a sender\\u200b,a recipient\\u200b,m)\n+    - Postcondition (Post Post): ð‘šâˆˆð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡.ð‘šð‘Žð‘–ð‘™ð‘ð‘œð‘¥ mâˆˆa recipient\\u200b.mailbox\n+\n+    Broadcast Messaging (ð‘€ð‘ð‘Ÿð‘œð‘Žð‘‘ð‘ð‘Žð‘ ð‘¡ð‘€broadcast\\u200b):\n+    - Precondition (Pre Pre): âˆƒð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿâˆˆð´ âˆƒa sender\\u200bâˆˆA\n+    - Action: ð‘ð‘Ÿð‘œð‘Žð‘‘ð‘ð‘Žð‘ ð‘¡ð‘€ð‘’ð‘ ð‘ ð‘Žð‘”ð‘’(ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘š) broadcastMessage(a sender\\u200b,m)\n+    - Postcondition (Post Post): âˆ€ð‘Žâˆˆð´âˆ–{ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ},ð‘šâˆˆð‘Ž.ð‘šð‘Žð‘–ð‘™ð‘ð‘œð‘¥ âˆ€aâˆˆAâˆ–{a sender\\u200b},mâˆˆa.mailbox\n+\n+3. System Invariants and Domain Assertions\n+    Invariant Preservation (ð¼ð‘ð‘Ÿð‘’ð‘ ð‘’ð‘Ÿð‘£ð‘’Ipreserve\\u200b):\n+    - Invariant (ð¼ I): Î¦(ð´,ð‘€) Î¦(A,M)\n+    - Upon Action (ð‘Žð‘ð‘¡ð‘–ð‘œð‘›action): ð‘Žð‘ð‘¡ð‘–ð‘œð‘›(ð´,ð‘€)â†’ð´â€²,ð‘€â€² action(A,M)â†’Aâ€²,Mâ€²\n+    - Preservation (ð¼â€²Iâ€²): Î¦(ð´â€²,ð‘€â€²) Î¦(Aâ€²,Mâ€²)\n+    Domain-Specific Logic Integration (ð·ð‘–ð‘›ð‘¡ð‘’ð‘”ð‘Ÿð‘Žð‘¡ð‘’Dintegrate\\u200b):\n+    - Precondition (Pre ð· Pre D\\u200b): Î”(ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™) Î”(s global\\u200b)\n+    - Action and Domain Logic: ð‘ð‘’ð‘Ÿð‘“ð‘œð‘Ÿð‘šð´ð‘ð‘¡ð‘–ð‘œð‘›ð‘Šð‘–ð‘¡â„Žð·ð‘œð‘šð‘Žð‘–ð‘›ð¿ð‘œð‘”ð‘–ð‘(ð‘Ž,ð‘š,Î”)â†’ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™â€²,Î”â€² performActionWithDomainLogic(a,m,Î”)â†’s globalâ€²\\u200b,Î”â€²\n+    - Postcondition (Post ð· Post D\\u200b): Î”â€²(ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™â€²) Î”â€²(s globalâ€²\\u200b)\n+\n+Implementation Details:\n+The ServiceColony is implemented with a focus on modularity, scalability, and ease of use. It provides a high-level API for inhabitant management and message passing, abstracting away the complexities of asynchronous programming and inhabitant coordination. Developers can leverage the ServiceColony to build complex, responsive applications that are both computationally correct and domain-compliant.\n+\n+Usage:\n+To use the ServiceColony, instantiate it within your application and use its methods to create inhabitants and manage message passing. The system integrates seamlessly with the asyncio event loop, making it straightforward to incorporate into existing asynchronous applications.\n+\n+The service_colony.py module, guided by the AMCN, provides a robust foundation for developing inhabitant-based systems within the RDDDY framework, ensuring that applications are built with a solid architectural foundation that promotes maintainability, scalability, and domain-driven design principles.\n+\"\"\"\n+import asyncio\n+import json\n+from typing import TYPE_CHECKING, Optional, TypeVar, cast\n+from paho.mqtt import client as mclient\n+\n+import reactivex as rx\n+from loguru import logger\n+from reactivex import operators as ops\n+from reactivex.scheduler.eventloop import AsyncIOScheduler\n+\n+from dspygen.rdddy.base_message import BaseMessage, MessageFactory\n+\n+if TYPE_CHECKING:\n+    from dspygen.rdddy.base_inhabitantimport BaseInhabitant\n+\n+T = TypeVar(\"T\", bound=\"BaseInhabitant\")\n+\n+\n+class ServiceColony:\n+    \"\"\"Orchestrates inhabitant lifecycle management, message passing, and system-wide coordination within the RDDDY framework.\n+\n+    The ServiceColony class provides functionalities for creating, managing, and terminating inhabitants, facilitating asynchronous message passing between them, and maintaining system invariants.\n+\n+    Attributes:\n+        inhabitants (dict): A dictionary containing inhabitant IDs as keys and corresponding inhabitant instances as values.\n+        loop (asyncio.AbstractEventLoop): The asyncio event loop used for asynchronous operations.\n+        scheduler (AsyncIOScheduler): An asynchronous scheduler for controlling task execution.\n+        event_stream (Subject): A subject for publishing events within the inhabitant system.\n+\n+    Methods:\n+        inhabitant_of(inhabitant_class, **kwargs): Creates a new inhabitant instance and starts its mailbox processing loop.\n+        inhabitants_of(inhabitant_classes, **kwargs): Creates multiple inhabitant instances of different types.\n+        publish(message): Publishes a message to the inhabitant system for distribution.\n+        remove_inhabitant(inhabitant_id): Removes an inhabitant from the inhabitant system.\n+        send(inhabitant_id, message): Sends a message to a specific inhabitant within the system.\n+        wait_for_event(event_type): Waits for a specific event type to occur within the system.\n+\n+    Implementation Details:\n+    The ServiceColony class implements inhabitant management and message passing functionalities, abstracting away the\n+    complexities of asynchronous programming and inhabitant coordination. It integrates seamlessly with the asyncio\n+    event loop, ensuring efficient concurrent operations.\n+\n+    Usage:\n+    Instantiate an ServiceColony object within your application to manage inhabitants and coordinate message passing. Use its\n+    methods to create inhabitants, send messages, and wait for specific events within the system.\n+    \"\"\"\n+\n+    def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None, websocket_uri: str = None):\n+        \"\"\"Initializes the ServiceColony.\n+\n+        Args:\n+            loop (asyncio.AbstractEventLoop, optional): The asyncio event loop to be used for asynchronous operations.\n+                If not provided, the default event loop will be used.\n+            websocket_uri (str, optional): The URI of the WebSocket server to connect to.\n+\n+        Attributes:\n+            websocket_uri (str): The URI of the WebSocket server.\n+            websocket: The WebSocket connection object.\n+            inhabitants (dict): A dictionary containing inhabitant IDs as keys and corresponding inhabitant instances as values.\n+            loop (asyncio.AbstractEventLoop): The asyncio event loop used for asynchronous operations.\n+            scheduler (AsyncIOScheduler): An asynchronous scheduler for controlling task execution.\n+            event_stream (Subject): A subject for publishing events within the inhabitant system.\n+        \"\"\"\n+        self.websocket_uri = websocket_uri\n+        self.websocket = None\n+        self.inhabitants: dict[int, \"BaseInhabitant\"] = {}\n+        self.loop = loop if loop is not None else asyncio.get_event_loop()\n+        self.scheduler = AsyncIOScheduler(loop=self.loop)\n+        self.event_stream = rx.subject.Subject()\n+\n+\n+    def on_connect(self, client, userdata, flags, reason_code, properties):\n+        print(\"Connected to MQTT Broker.\")\n+        client.subscribe(\"service_colony/publish\")  # Subscribe to the topic\n+\n+    def on_message(self, client, userdata, msg):\n+        print(f\"Received message from topic {msg.topic}: {msg.payload}\")\n+        # Deserialize the message payload into your internal message format\n+        payload_dict = json.loads(msg.payload)\n+        message = MessageFactory.create_message(payload_dict) # Implement this method based on your message class\n+        asyncio.run_coroutine_threadsafe(self.distribute_message(message), self.loop)\n+\n+    async def distribute_message(self, message):\n+        # Prevent republishing to MQTT by directly invoking the local distribution logic\n+        self.event_stream.on_next(message)\n+        inhabitants = list(self.inhabitants.values())\n+        for inhabitant in inhabitants:\n+            await self.send(inhabitant.inhabitant_id, message)\n+\n+    async def inhabitant_of(self, inhabitant_class, **kwargs) -> T:\n+        \"\"\"Creates a new inhabitant instance and starts its mailbox processing loop.\n+        T = TypeVar(\"T\", bound=\"Actor\")\n+\n+        Preconditions (Pre):\n+            - None\n+\n+        Transition (T):\n+            - Creates a new instance of the specified inhabitant class.\n+            - Initializes the inhabitant's mailbox.\n+            - Starts the processing loop for the inhabitant's mailbox, enabling asynchronous message handling.\n+\n+        Postconditions (Post):\n+            - A new inhabitant instance has been created and started successfully.\n+\n+        Args:\n+            inhabitant_class: The class of the inhabitant to be created.\n+            **kwargs: Additional keyword arguments to be passed to the inhabitant constructor.\n+\n+        Returns:\n+            T: The created inhabitant instance.\n+        \"\"\"\n+        inhabitant = inhabitant_class(self, **kwargs)\n+        self.inhabitants[inhabitant.inhabitant_id] = inhabitant\n+        await inhabitant.start(self.scheduler)\n+        logger.info(f\"Actor {inhabitant.inhabitant_id} started\")\n+        return inhabitant\n+\n+    async def inhabitants_of(self, inhabitant_classes, **kwargs) -> list[T]:\n+        \"\"\"Creates multiple inhabitant instances of different types and starts their mailbox processing loops.\n+        T = TypeVar(\"T\", bound=\"Actor\")\n+\n+        Preconditions (Pre):\n+            - None\n+\n+        Transition (T):\n+            - Creates new instances of the specified inhabitant classes.\n+            - Initializes the mailboxes for each inhabitant.\n+            - Starts the processing loop for each inhabitant's mailbox, enabling asynchronous message handling.\n+\n+        Postconditions (Post):\n+            - Multiple inhabitant instances have been created and started successfully.\n+\n+        Args:\n+            inhabitant_classes (List[Type]): A list of inhabitant classes to be instantiated.\n+            **kwargs: Additional keyword arguments to be passed to the inhabitant constructors.\n+\n+        Returns:\n+            List[T]: A list containing the created inhabitant instances.\n+        \"\"\"\n+        inhabitants = []\n+        for inhabitant_class in inhabitant_classes:\n+            inhabitant = await self.inhabitant_of(inhabitant_class, **kwargs)\n+            inhabitants.append(inhabitant)\n+        return inhabitants\n+\n+    async def publish(self, message: \"BaseMessage\"):\n+        \"\"\"Publishes a message to the inhabitant system for distribution.\n+\n+        Preconditions (Pre):\n+            - None\n+\n+        Transition (T):\n+            - Emits the message to the event stream of the inhabitant system.\n+            - Sends the message to each inhabitant within the system for processing.\n+\n+        Postconditions (Post):\n+            - The message has been published to the inhabitant system and processed by relevant inhabitants.\n+            - If the message is an instance of the base Message class, an error is raised.\n+\n+        Args:\n+            message (BaseMessage): The message to be published to the inhabitant system.\n+\n+        Raises:\n+            ValueError: If the base Message class is used directly.\n+        \"\"\"\n+        logger.debug(f\"Publishing message: {message}\")\n+\n+        if type(message) is BaseMessage:\n+            raise ValueError(\n+                \"The base Message class should not be used directly. Please use a subclass of Message.\"\n+            )\n+\n+        if self.websocket:\n+            await self.websocket.send(json.dumps(message.model_dump_json()))\n+        self.event_stream.on_next(message)\n+        inhabitants = list(self.inhabitants.values())\n+        for inhabitant in inhabitants:\n+            await self.send(inhabitant.inhabitant_id, message)\n+\n+    async def remove_inhabitant(self, inhabitant_id):\n+        \"\"\"Removes an inhabitant from the inhabitant system.\n+\n+        Preconditions (Pre):\n+            - The inhabitant ID must exist in the inhabitant system.\n+\n+        Transition (T):\n+            - Removes the inhabitant with the specified ID from the inhabitant system.\n+\n+        Postconditions (Post):\n+            - The inhabitant has been successfully removed from the inhabitant system.\n+\n+        Args:\n+            inhabitant_id: The ID of the inhabitant to be removed.\n+        \"\"\"\n+        inhabitant = self.inhabitants.pop(inhabitant_id, None)\n+        if inhabitant:\n+            logger.debug(f\"Removing inhabitant {inhabitant_id}\")\n+        else:\n+            logger.debug(f\"Actor {inhabitant_id} not found for removal\")\n+        logger.debug(f\"Current inhabitants count: {len(self.inhabitants)}\")\n+\n+    async def send(self, inhabitant_id: int, message: \"BaseMessage\"):\n+        \"\"\"Sends a message to a specific inhabitant within the inhabitant system.\n+\n+        Preconditions (Pre):\n+            - The inhabitant ID must exist in the inhabitant system.\n+            - The message must be an instance of the Message class.\n+\n+        Transition (T):\n+            - Delivers the message to the specified inhabitant's mailbox for processing.\n+\n+        Postconditions (Post):\n+            - The message has been successfully sent to the specified inhabitant for processing.\n+\n+        Args:\n+            inhabitant_id (int): The ID of the target inhabitant.\n+            message (BaseMessage): The message to be sent to the target inhabitant.\n+        \"\"\"\n+        # logger.debug(f\"Sending message {message} to inhabitant {inhabitant_id}\")\n+        inhabitant = self.inhabitants.get(inhabitant_id)\n+        if inhabitant:\n+            inhabitant.mailbox.on_next(message)\n+            await asyncio.sleep(0)\n+        else:\n+            logger.debug(f\"Actor {inhabitant_id} not found.\")\n+\n+    async def wait_for_message(self, message_type: type) -> \"BaseMessage\":\n+        \"\"\"Waits for a message of a specific type to be published to the inhabitant system.\n+\n+        Preconditions (Pre):\n+            - None\n+\n+        Transition (T):\n+            - Subscribes to the event stream of the inhabitant system.\n+            - Waits until a message of the specified type is published.\n+\n+        Postconditions (Post):\n+            - A message of the specified type has been received from the inhabitant system.\n+\n+        Args:\n+            message_type (type): The type of message to wait for.\n+\n+        Returns:\n+            asyncio.Future: A future object representing the awaited message.\n+        \"\"\"\n+        loop = asyncio.get_event_loop()\n+        future = loop.create_future()\n+\n+        def on_next(msg):\n+            if isinstance(msg, message_type):\n+                future.set_result(msg)\n+                subscription.dispose()\n+\n+        subscription = self.event_stream.pipe(\n+            ops.filter(lambda msg: isinstance(msg, message_type))\n+        ).subscribe(on_next)\n+\n+        return await future\n+\n+    def __getitem__(self, inhabitant_id) -> T:\n+        \"\"\"Retrieves an inhabitant by its ID from the inhabitant system.\n+\n+        Preconditions (Pre):\n+            - The inhabitant ID must exist in the inhabitant system.\n+\n+        Transition (T):\n+            - Retrieves the inhabitant with the specified ID from the inhabitant system.\n+\n+        Postconditions (Post):\n+            - The inhabitant with the specified ID has been successfully retrieved from the inhabitant system.\n+\n+        Args:\n+            inhabitant_id: The ID of the inhabitant to retrieve.\n+\n+        Returns:\n+            BaseInhabitant: The inhabitant object corresponding to the specified ID.\n+        \"\"\"\n+        return cast(T, self.inhabitants.get(inhabitant_id))\n+\n+\n+    async def shutdown(self):\n+        \"\"\"Shuts down the inhabitant system and terminates all inhabitants.\n+\n+        Preconditions (Pre):\n+            - None\n+\n+        Transition (T):\n+            - Terminates all inhabitants within the inhabitant system.\n+            - Closes the event stream and scheduler.\n+\n+        Postconditions (Post):\n+            - The inhabitant system has been successfully shut down.\n+        \"\"\"\n+        if self.websocket:\n+            await self.websocket.close()\n+        logger.debug(\"Actor system shutdown complete.\")\n+\n+\n+import asyncio\n+\n+\n+async def main():\n+    print(\"main\")\n+    # await\n+\n+\n+if __name__ == \"__main__\":\n+    asyncio.run(main())\n"
                },
                {
                    "date": 1724107056148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,8 +71,10 @@\n         inhabitants (dict): A dictionary containing inhabitant IDs as keys and corresponding inhabitant instances as values.\n         loop (asyncio.AbstractEventLoop): The asyncio event loop used for asynchronous operations.\n         scheduler (AsyncIOScheduler): An asynchronous scheduler for controlling task execution.\n         event_stream (Subject): A subject for publishing events within the inhabitant system.\n+        websocket_uri (str): The URI of the WebSocket server to connect to.\n+        websocket: The WebSocket connection object.\n \n     Methods:\n         inhabitant_of(inhabitant_class, **kwargs): Creates a new inhabitant instance and starts its mailbox processing loop.\n         inhabitants_of(inhabitant_classes, **kwargs): Creates multiple inhabitant instances of different types.\n@@ -351,358 +353,4 @@\n \n \n if __name__ == \"__main__\":\n     asyncio.run(main())\n-\"\"\"\n-Actor System Module Documentation\n-\n-This module, service_colony.py, implements the ServiceColony class within the Reactive Domain-Driven Design (RDDDY) framework. It serves as the orchestrator for inhabitant lifecycle management, message passing, and system-wide coordination, ensuring that the principles of the Inhabitant model are adhered to in a domain-driven context.\n-\n-Overview:\n-The ServiceColony is responsible for creating, managing, and terminating inhabitants, facilitating asynchronous message passing between them, and maintaining system invariants. It is designed to operate seamlessly within an asynchronous programming environment, leveraging Python's asyncio library to handle concurrent operations efficiently.\n-\n-ServiceColony Multiline Calculus Notation (AMCN):\n-The behavior and operations within the ServiceColony are rigorously defined by the ServiceColony Multiline Calculus Notation (AMCN), ensuring a formalized approach to inhabitant management and message dissemination. The AMCN outlines the preconditions, actions, and postconditions for each operation within the system, integrating domain-specific assertions to align computational processes with the system's domain logic.\n-\n-1. Inhabitant Lifecycle Management\n-    Inhabitant Creation (ð´ð‘ð‘Ÿð‘’ð‘Žð‘¡ð‘’Acreate\\u200b):\n-    - Precondition (Pre Pre): Â¬âˆƒð‘Žâˆˆð´âˆ£ð‘Ž.ð‘–ð‘‘=ð‘–ð‘‘ð‘›ð‘’ð‘¤ Â¬âˆƒaâˆˆAâˆ£a.id=id new\\u200b\n-    - Action: ð‘ð‘Ÿð‘’ð‘Žð‘¡ð‘’ð´ð‘ð‘¡ð‘œð‘Ÿ(ð‘–ð‘‘ð‘›ð‘’ð‘¤,ð‘‡ð‘¦ð‘ð‘’)â†’ð‘Žð‘›ð‘’ð‘¤ createInhabitant(id new\\u200b,Type)â†’a new\\u200b\n-    - Postcondition (Post Post): âˆƒð‘Žâˆˆð´âˆ£ð‘Ž.ð‘–ð‘‘=ð‘–ð‘‘ð‘›ð‘’ð‘¤âˆ§ð‘Ž.ð‘¡ð‘¦ð‘ð‘’=ð‘‡ð‘¦ð‘ð‘’ âˆƒaâˆˆAâˆ£a.id=id new\\u200bâˆ§a.type=Type\n-\n-2. Message Dispatching\n-    Direct Message Sending (ð‘€ð‘ ð‘’ð‘›ð‘‘Msend\\u200b):\n-    - Precondition (Pre Pre): âˆƒð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡âˆˆð´ âˆƒa sender\\u200b,a recipient\\u200bâˆˆA\n-    - Action: ð‘ ð‘’ð‘›ð‘‘ð‘€ð‘’ð‘ ð‘ ð‘Žð‘”ð‘’(ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡,ð‘š) sendMessage(a sender\\u200b,a recipient\\u200b,m)\n-    - Postcondition (Post Post): ð‘šâˆˆð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡.ð‘šð‘Žð‘–ð‘™ð‘ð‘œð‘¥ mâˆˆa recipient\\u200b.mailbox\n-\n-    Broadcast Messaging (ð‘€ð‘ð‘Ÿð‘œð‘Žð‘‘ð‘ð‘Žð‘ ð‘¡ð‘€broadcast\\u200b):\n-    - Precondition (Pre Pre): âˆƒð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿâˆˆð´ âˆƒa sender\\u200bâˆˆA\n-    - Action: ð‘ð‘Ÿð‘œð‘Žð‘‘ð‘ð‘Žð‘ ð‘¡ð‘€ð‘’ð‘ ð‘ ð‘Žð‘”ð‘’(ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘š) broadcastMessage(a sender\\u200b,m)\n-    - Postcondition (Post Post): âˆ€ð‘Žâˆˆð´âˆ–{ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ},ð‘šâˆˆð‘Ž.ð‘šð‘Žð‘–ð‘™ð‘ð‘œð‘¥ âˆ€aâˆˆAâˆ–{a sender\\u200b},mâˆˆa.mailbox\n-\n-3. System Invariants and Domain Assertions\n-    Invariant Preservation (ð¼ð‘ð‘Ÿð‘’ð‘ ð‘’ð‘Ÿð‘£ð‘’Ipreserve\\u200b):\n-    - Invariant (ð¼ I): Î¦(ð´,ð‘€) Î¦(A,M)\n-    - Upon Action (ð‘Žð‘ð‘¡ð‘–ð‘œð‘›action): ð‘Žð‘ð‘¡ð‘–ð‘œð‘›(ð´,ð‘€)â†’ð´â€²,ð‘€â€² action(A,M)â†’Aâ€²,Mâ€²\n-    - Preservation (ð¼â€²Iâ€²): Î¦(ð´â€²,ð‘€â€²) Î¦(Aâ€²,Mâ€²)\n-    Domain-Specific Logic Integration (ð·ð‘–ð‘›ð‘¡ð‘’ð‘”ð‘Ÿð‘Žð‘¡ð‘’Dintegrate\\u200b):\n-    - Precondition (Pre ð· Pre D\\u200b): Î”(ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™) Î”(s global\\u200b)\n-    - Action and Domain Logic: ð‘ð‘’ð‘Ÿð‘“ð‘œð‘Ÿð‘šð´ð‘ð‘¡ð‘–ð‘œð‘›ð‘Šð‘–ð‘¡â„Žð·ð‘œð‘šð‘Žð‘–ð‘›ð¿ð‘œð‘”ð‘–ð‘(ð‘Ž,ð‘š,Î”)â†’ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™â€²,Î”â€² performActionWithDomainLogic(a,m,Î”)â†’s globalâ€²\\u200b,Î”â€²\n-    - Postcondition (Post ð· Post D\\u200b): Î”â€²(ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™â€²) Î”â€²(s globalâ€²\\u200b)\n-\n-Implementation Details:\n-The ServiceColony is implemented with a focus on modularity, scalability, and ease of use. It provides a high-level API for inhabitant management and message passing, abstracting away the complexities of asynchronous programming and inhabitant coordination. Developers can leverage the ServiceColony to build complex, responsive applications that are both computationally correct and domain-compliant.\n-\n-Usage:\n-To use the ServiceColony, instantiate it within your application and use its methods to create inhabitants and manage message passing. The system integrates seamlessly with the asyncio event loop, making it straightforward to incorporate into existing asynchronous applications.\n-\n-The service_colony.py module, guided by the AMCN, provides a robust foundation for developing inhabitant-based systems within the RDDDY framework, ensuring that applications are built with a solid architectural foundation that promotes maintainability, scalability, and domain-driven design principles.\n-\"\"\"\n-import asyncio\n-import json\n-from typing import TYPE_CHECKING, Optional, TypeVar, cast\n-from paho.mqtt import client as mclient\n-\n-import reactivex as rx\n-from loguru import logger\n-from reactivex import operators as ops\n-from reactivex.scheduler.eventloop import AsyncIOScheduler\n-\n-from dspygen.rdddy.base_message import BaseMessage, MessageFactory\n-\n-if TYPE_CHECKING:\n-    from dspygen.rdddy.base_inhabitantimport BaseInhabitant\n-\n-T = TypeVar(\"T\", bound=\"BaseInhabitant\")\n-\n-\n-class ServiceColony:\n-    \"\"\"Orchestrates inhabitant lifecycle management, message passing, and system-wide coordination within the RDDDY framework.\n-\n-    The ServiceColony class provides functionalities for creating, managing, and terminating inhabitants, facilitating asynchronous message passing between them, and maintaining system invariants.\n-\n-    Attributes:\n-        inhabitants (dict): A dictionary containing inhabitant IDs as keys and corresponding inhabitant instances as values.\n-        loop (asyncio.AbstractEventLoop): The asyncio event loop used for asynchronous operations.\n-        scheduler (AsyncIOScheduler): An asynchronous scheduler for controlling task execution.\n-        event_stream (Subject): A subject for publishing events within the inhabitant system.\n-\n-    Methods:\n-        inhabitant_of(inhabitant_class, **kwargs): Creates a new inhabitant instance and starts its mailbox processing loop.\n-        inhabitants_of(inhabitant_classes, **kwargs): Creates multiple inhabitant instances of different types.\n-        publish(message): Publishes a message to the inhabitant system for distribution.\n-        remove_inhabitant(inhabitant_id): Removes an inhabitant from the inhabitant system.\n-        send(inhabitant_id, message): Sends a message to a specific inhabitant within the system.\n-        wait_for_event(event_type): Waits for a specific event type to occur within the system.\n-\n-    Implementation Details:\n-    The ServiceColony class implements inhabitant management and message passing functionalities, abstracting away the\n-    complexities of asynchronous programming and inhabitant coordination. It integrates seamlessly with the asyncio\n-    event loop, ensuring efficient concurrent operations.\n-\n-    Usage:\n-    Instantiate an ServiceColony object within your application to manage inhabitants and coordinate message passing. Use its\n-    methods to create inhabitants, send messages, and wait for specific events within the system.\n-    \"\"\"\n-\n-    def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None, websocket_uri: str = None):\n-        \"\"\"Initializes the ServiceColony.\n-\n-        Args:\n-            loop (asyncio.AbstractEventLoop, optional): The asyncio event loop to be used for asynchronous operations.\n-                If not provided, the default event loop will be used.\n-            websocket_uri (str, optional): The URI of the WebSocket server to connect to.\n-\n-        Attributes:\n-            websocket_uri (str): The URI of the WebSocket server.\n-            websocket: The WebSocket connection object.\n-            inhabitants (dict): A dictionary containing inhabitant IDs as keys and corresponding inhabitant instances as values.\n-            loop (asyncio.AbstractEventLoop): The asyncio event loop used for asynchronous operations.\n-            scheduler (AsyncIOScheduler): An asynchronous scheduler for controlling task execution.\n-            event_stream (Subject): A subject for publishing events within the inhabitant system.\n-        \"\"\"\n-        self.websocket_uri = websocket_uri\n-        self.websocket = None\n-        self.inhabitants: dict[int, \"BaseInhabitant\"] = {}\n-        self.loop = loop if loop is not None else asyncio.get_event_loop()\n-        self.scheduler = AsyncIOScheduler(loop=self.loop)\n-        self.event_stream = rx.subject.Subject()\n-\n-\n-    def on_connect(self, client, userdata, flags, reason_code, properties):\n-        print(\"Connected to MQTT Broker.\")\n-        client.subscribe(\"service_colony/publish\")  # Subscribe to the topic\n-\n-    def on_message(self, client, userdata, msg):\n-        print(f\"Received message from topic {msg.topic}: {msg.payload}\")\n-        # Deserialize the message payload into your internal message format\n-        payload_dict = json.loads(msg.payload)\n-        message = MessageFactory.create_message(payload_dict) # Implement this method based on your message class\n-        asyncio.run_coroutine_threadsafe(self.distribute_message(message), self.loop)\n-\n-    async def distribute_message(self, message):\n-        # Prevent republishing to MQTT by directly invoking the local distribution logic\n-        self.event_stream.on_next(message)\n-        inhabitants = list(self.inhabitants.values())\n-        for inhabitant in inhabitants:\n-            await self.send(inhabitant.inhabitant_id, message)\n-\n-    async def inhabitant_of(self, inhabitant_class, **kwargs) -> T:\n-        \"\"\"Creates a new inhabitant instance and starts its mailbox processing loop.\n-        T = TypeVar(\"T\", bound=\"Actor\")\n-\n-        Preconditions (Pre):\n-            - None\n-\n-        Transition (T):\n-            - Creates a new instance of the specified inhabitant class.\n-            - Initializes the inhabitant's mailbox.\n-            - Starts the processing loop for the inhabitant's mailbox, enabling asynchronous message handling.\n-\n-        Postconditions (Post):\n-            - A new inhabitant instance has been created and started successfully.\n-\n-        Args:\n-            inhabitant_class: The class of the inhabitant to be created.\n-            **kwargs: Additional keyword arguments to be passed to the inhabitant constructor.\n-\n-        Returns:\n-            T: The created inhabitant instance.\n-        \"\"\"\n-        inhabitant = inhabitant_class(self, **kwargs)\n-        self.inhabitants[inhabitant.inhabitant_id] = inhabitant\n-        await inhabitant.start(self.scheduler)\n-        logger.info(f\"Actor {inhabitant.inhabitant_id} started\")\n-        return inhabitant\n-\n-    async def inhabitants_of(self, inhabitant_classes, **kwargs) -> list[T]:\n-        \"\"\"Creates multiple inhabitant instances of different types and starts their mailbox processing loops.\n-        T = TypeVar(\"T\", bound=\"Actor\")\n-\n-        Preconditions (Pre):\n-            - None\n-\n-        Transition (T):\n-            - Creates new instances of the specified inhabitant classes.\n-            - Initializes the mailboxes for each inhabitant.\n-            - Starts the processing loop for each inhabitant's mailbox, enabling asynchronous message handling.\n-\n-        Postconditions (Post):\n-            - Multiple inhabitant instances have been created and started successfully.\n-\n-        Args:\n-            inhabitant_classes (List[Type]): A list of inhabitant classes to be instantiated.\n-            **kwargs: Additional keyword arguments to be passed to the inhabitant constructors.\n-\n-        Returns:\n-            List[T]: A list containing the created inhabitant instances.\n-        \"\"\"\n-        inhabitants = []\n-        for inhabitant_class in inhabitant_classes:\n-            inhabitant = await self.inhabitant_of(inhabitant_class, **kwargs)\n-            inhabitants.append(inhabitant)\n-        return inhabitants\n-\n-    async def publish(self, message: \"BaseMessage\"):\n-        \"\"\"Publishes a message to the inhabitant system for distribution.\n-\n-        Preconditions (Pre):\n-            - None\n-\n-        Transition (T):\n-            - Emits the message to the event stream of the inhabitant system.\n-            - Sends the message to each inhabitant within the system for processing.\n-\n-        Postconditions (Post):\n-            - The message has been published to the inhabitant system and processed by relevant inhabitants.\n-            - If the message is an instance of the base Message class, an error is raised.\n-\n-        Args:\n-            message (BaseMessage): The message to be published to the inhabitant system.\n-\n-        Raises:\n-            ValueError: If the base Message class is used directly.\n-        \"\"\"\n-        logger.debug(f\"Publishing message: {message}\")\n-\n-        if type(message) is BaseMessage:\n-            raise ValueError(\n-                \"The base Message class should not be used directly. Please use a subclass of Message.\"\n-            )\n-\n-        if self.websocket:\n-            await self.websocket.send(json.dumps(message.model_dump_json()))\n-        self.event_stream.on_next(message)\n-        inhabitants = list(self.inhabitants.values())\n-        for inhabitant in inhabitants:\n-            await self.send(inhabitant.inhabitant_id, message)\n-\n-    async def remove_inhabitant(self, inhabitant_id):\n-        \"\"\"Removes an inhabitant from the inhabitant system.\n-\n-        Preconditions (Pre):\n-            - The inhabitant ID must exist in the inhabitant system.\n-\n-        Transition (T):\n-            - Removes the inhabitant with the specified ID from the inhabitant system.\n-\n-        Postconditions (Post):\n-            - The inhabitant has been successfully removed from the inhabitant system.\n-\n-        Args:\n-            inhabitant_id: The ID of the inhabitant to be removed.\n-        \"\"\"\n-        inhabitant = self.inhabitants.pop(inhabitant_id, None)\n-        if inhabitant:\n-            logger.debug(f\"Removing inhabitant {inhabitant_id}\")\n-        else:\n-            logger.debug(f\"Actor {inhabitant_id} not found for removal\")\n-        logger.debug(f\"Current inhabitants count: {len(self.inhabitants)}\")\n-\n-    async def send(self, inhabitant_id: int, message: \"BaseMessage\"):\n-        \"\"\"Sends a message to a specific inhabitant within the inhabitant system.\n-\n-        Preconditions (Pre):\n-            - The inhabitant ID must exist in the inhabitant system.\n-            - The message must be an instance of the Message class.\n-\n-        Transition (T):\n-            - Delivers the message to the specified inhabitant's mailbox for processing.\n-\n-        Postconditions (Post):\n-            - The message has been successfully sent to the specified inhabitant for processing.\n-\n-        Args:\n-            inhabitant_id (int): The ID of the target inhabitant.\n-            message (BaseMessage): The message to be sent to the target inhabitant.\n-        \"\"\"\n-        # logger.debug(f\"Sending message {message} to inhabitant {inhabitant_id}\")\n-        inhabitant = self.inhabitants.get(inhabitant_id)\n-        if inhabitant:\n-            inhabitant.mailbox.on_next(message)\n-            await asyncio.sleep(0)\n-        else:\n-            logger.debug(f\"Actor {inhabitant_id} not found.\")\n-\n-    async def wait_for_message(self, message_type: type) -> \"BaseMessage\":\n-        \"\"\"Waits for a message of a specific type to be published to the inhabitant system.\n-\n-        Preconditions (Pre):\n-            - None\n-\n-        Transition (T):\n-            - Subscribes to the event stream of the inhabitant system.\n-            - Waits until a message of the specified type is published.\n-\n-        Postconditions (Post):\n-            - A message of the specified type has been received from the inhabitant system.\n-\n-        Args:\n-            message_type (type): The type of message to wait for.\n-\n-        Returns:\n-            asyncio.Future: A future object representing the awaited message.\n-        \"\"\"\n-        loop = asyncio.get_event_loop()\n-        future = loop.create_future()\n-\n-        def on_next(msg):\n-            if isinstance(msg, message_type):\n-                future.set_result(msg)\n-                subscription.dispose()\n-\n-        subscription = self.event_stream.pipe(\n-            ops.filter(lambda msg: isinstance(msg, message_type))\n-        ).subscribe(on_next)\n-\n-        return await future\n-\n-    def __getitem__(self, inhabitant_id) -> T:\n-        \"\"\"Retrieves an inhabitant by its ID from the inhabitant system.\n-\n-        Preconditions (Pre):\n-            - The inhabitant ID must exist in the inhabitant system.\n-\n-        Transition (T):\n-            - Retrieves the inhabitant with the specified ID from the inhabitant system.\n-\n-        Postconditions (Post):\n-            - The inhabitant with the specified ID has been successfully retrieved from the inhabitant system.\n-\n-        Args:\n-            inhabitant_id: The ID of the inhabitant to retrieve.\n-\n-        Returns:\n-            BaseInhabitant: The inhabitant object corresponding to the specified ID.\n-        \"\"\"\n-        return cast(T, self.inhabitants.get(inhabitant_id))\n-\n-\n-    async def shutdown(self):\n-        \"\"\"Shuts down the inhabitant system and terminates all inhabitants.\n-\n-        Preconditions (Pre):\n-            - None\n-\n-        Transition (T):\n-            - Terminates all inhabitants within the inhabitant system.\n-            - Closes the event stream and scheduler.\n-\n-        Postconditions (Post):\n-            - The inhabitant system has been successfully shut down.\n-        \"\"\"\n-        # self.mqtt_client.loop_stop()\n-        # self.mqtt_client.disconnect()\n-        logger.debug(\"Actor system shutdown complete.\")\n-\n-\n-import asyncio\n-\n-\n-async def main():\n-    print(\"main\")\n-    # await\n-\n-\n-if __name__ == \"__main__\":\n-    asyncio.run(main())\n"
                },
                {
                    "date": 1724107061788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,13 +89,15 @@\n \n     Implementation Details:\n     The ServiceColony class implements inhabitant management and message passing functionalities, abstracting away the\n     complexities of asynchronous programming and inhabitant coordination. It integrates seamlessly with the asyncio\n-    event loop, ensuring efficient concurrent operations.\n+    event loop, ensuring efficient concurrent operations. Additionally, it supports MQTT communication for\n+    distributed inhabitant systems.\n \n     Usage:\n     Instantiate an ServiceColony object within your application to manage inhabitants and coordinate message passing. Use its\n-    methods to create inhabitants, send messages, and wait for specific events within the system.\n+    methods to create inhabitants, send messages, and wait for specific messages within the system. For distributed systems,\n+    provide a WebSocket URI during initialization to enable remote communication.\n     \"\"\"\n \n     def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None, websocket_uri: str = None):\n         \"\"\"Initializes the ServiceColony.\n"
                },
                {
                    "date": 1724107068761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,13 @@\n         inhabitants_of(inhabitant_classes, **kwargs): Creates multiple inhabitant instances of different types.\n         publish(message): Publishes a message to the inhabitant system for distribution.\n         remove_inhabitant(inhabitant_id): Removes an inhabitant from the inhabitant system.\n         send(inhabitant_id, message): Sends a message to a specific inhabitant within the system.\n-        wait_for_event(event_type): Waits for a specific event type to occur within the system.\n+        wait_for_message(message_type): Waits for a specific message type to occur within the system.\n+        on_connect(client, userdata, flags, reason_code, properties): Callback for MQTT connection.\n+        on_message(client, userdata, msg): Callback for receiving MQTT messages.\n+        distribute_message(message): Distributes a message within the inhabitant system.\n+        shutdown(): Shuts down the inhabitant system and terminates all inhabitants.\n \n     Implementation Details:\n     The ServiceColony class implements inhabitant management and message passing functionalities, abstracting away the\n     complexities of asynchronous programming and inhabitant coordination. It integrates seamlessly with the asyncio\n@@ -100,9 +104,9 @@\n \n         Args:\n             loop (asyncio.AbstractEventLoop, optional): The asyncio event loop to be used for asynchronous operations.\n                 If not provided, the default event loop will be used.\n-            websocket_uri (str, optional): The URI of the WebSocket server to connect to.\n+            websocket_uri (str, optional): The URI of the WebSocket server to connect to for distributed communication.\n \n         Attributes:\n             websocket_uri (str): The URI of the WebSocket server.\n             websocket: The WebSocket connection object.\n@@ -119,12 +123,34 @@\n         self.event_stream = rx.subject.Subject()\n \n \n     def on_connect(self, client, userdata, flags, reason_code, properties):\n+        \"\"\"Callback function for MQTT connection.\n+\n+        This method is called when the MQTT client successfully connects to the broker.\n+        It subscribes to the 'service_colony/publish' topic.\n+\n+        Args:\n+            client: The MQTT client instance.\n+            userdata: User-defined data passed to the callback.\n+            flags: Response flags sent by the broker.\n+            reason_code: The connection result.\n+            properties: The MQTT 5.0 properties returned from the broker.\n+        \"\"\"\n         print(\"Connected to MQTT Broker.\")\n         client.subscribe(\"service_colony/publish\")  # Subscribe to the topic\n \n     def on_message(self, client, userdata, msg):\n+        \"\"\"Callback function for receiving MQTT messages.\n+\n+        This method is called when a message is received on the subscribed MQTT topic.\n+        It deserializes the message and distributes it within the inhabitant system.\n+\n+        Args:\n+            client: The MQTT client instance.\n+            userdata: User-defined data passed to the callback.\n+            msg: The received message.\n+        \"\"\"\n         print(f\"Received message from topic {msg.topic}: {msg.payload}\")\n         # Deserialize the message payload into your internal message format\n         payload_dict = json.loads(msg.payload)\n         message = MessageFactory.create_message(payload_dict) # Implement this method based on your message class\n"
                },
                {
                    "date": 1724107079822,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -235,8 +235,9 @@\n \n         Transition (T):\n             - Emits the message to the event stream of the inhabitant system.\n             - Sends the message to each inhabitant within the system for processing.\n+            - If a WebSocket connection is available, sends the message through it.\n \n         Postconditions (Post):\n             - The message has been published to the inhabitant system and processed by relevant inhabitants.\n             - If the message is an instance of the base Message class, an error is raised.\n"
                },
                {
                    "date": 1724107092424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -371,17 +371,17 @@\n \n         Transition (T):\n             - Terminates all inhabitants within the inhabitant system.\n             - Closes the event stream and scheduler.\n+            - If a WebSocket connection exists, closes it.\n \n         Postconditions (Post):\n             - The inhabitant system has been successfully shut down.\n         \"\"\"\n         if self.websocket:\n             await self.websocket.close()\n         logger.debug(\"Actor system shutdown complete.\")\n \n-\n import asyncio\n \n \n async def main():\n"
                },
                {
                    "date": 1724107154721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,8 +156,16 @@\n         message = MessageFactory.create_message(payload_dict) # Implement this method based on your message class\n         asyncio.run_coroutine_threadsafe(self.distribute_message(message), self.loop)\n \n     async def distribute_message(self, message):\n+        \"\"\"Distributes a message within the inhabitant system.\n+\n+        This method is responsible for publishing the message to the event stream\n+        and sending it to all inhabitants in the system.\n+\n+        Args:\n+            message: The message to be distributed.\n+        \"\"\"\n         # Prevent republishing to MQTT by directly invoking the local distribution logic\n         self.event_stream.on_next(message)\n         inhabitants = list(self.inhabitants.values())\n         for inhabitant in inhabitants:\n@@ -372,8 +380,9 @@\n         if self.websocket:\n             await self.websocket.close()\n         logger.debug(\"Actor system shutdown complete.\")\n \n+\n import asyncio\n \n \n async def main():\n"
                }
            ],
            "date": 1724106946022,
            "name": "Commit-0",
            "content": "\"\"\"\nActor System Module Documentation\n\nThis module, service_colony.py, implements the ServiceColony class within the Reactive Domain-Driven Design (RDDDY) framework. It serves as the orchestrator for inhabitant lifecycle management, message passing, and system-wide coordination, ensuring that the principles of the Inhabitant model are adhered to in a domain-driven context.\n\nOverview:\nThe ServiceColony is responsible for creating, managing, and terminating inhabitants, facilitating asynchronous message passing between them, and maintaining system invariants. It is designed to operate seamlessly within an asynchronous programming environment, leveraging Python's asyncio library to handle concurrent operations efficiently.\n\nServiceColony Multiline Calculus Notation (AMCN):\nThe behavior and operations within the ServiceColony are rigorously defined by the ServiceColony Multiline Calculus Notation (AMCN), ensuring a formalized approach to inhabitant management and message dissemination. The AMCN outlines the preconditions, actions, and postconditions for each operation within the system, integrating domain-specific assertions to align computational processes with the system's domain logic.\n\n1. Inhabitant Lifecycle Management\n    Inhabitant Creation (ð´ð‘ð‘Ÿð‘’ð‘Žð‘¡ð‘’Acreate\\u200b):\n    - Precondition (Pre Pre): Â¬âˆƒð‘Žâˆˆð´âˆ£ð‘Ž.ð‘–ð‘‘=ð‘–ð‘‘ð‘›ð‘’ð‘¤ Â¬âˆƒaâˆˆAâˆ£a.id=id new\\u200b\n    - Action: ð‘ð‘Ÿð‘’ð‘Žð‘¡ð‘’ð´ð‘ð‘¡ð‘œð‘Ÿ(ð‘–ð‘‘ð‘›ð‘’ð‘¤,ð‘‡ð‘¦ð‘ð‘’)â†’ð‘Žð‘›ð‘’ð‘¤ createInhabitant(id new\\u200b,Type)â†’a new\\u200b\n    - Postcondition (Post Post): âˆƒð‘Žâˆˆð´âˆ£ð‘Ž.ð‘–ð‘‘=ð‘–ð‘‘ð‘›ð‘’ð‘¤âˆ§ð‘Ž.ð‘¡ð‘¦ð‘ð‘’=ð‘‡ð‘¦ð‘ð‘’ âˆƒaâˆˆAâˆ£a.id=id new\\u200bâˆ§a.type=Type\n\n2. Message Dispatching\n    Direct Message Sending (ð‘€ð‘ ð‘’ð‘›ð‘‘Msend\\u200b):\n    - Precondition (Pre Pre): âˆƒð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡âˆˆð´ âˆƒa sender\\u200b,a recipient\\u200bâˆˆA\n    - Action: ð‘ ð‘’ð‘›ð‘‘ð‘€ð‘’ð‘ ð‘ ð‘Žð‘”ð‘’(ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡,ð‘š) sendMessage(a sender\\u200b,a recipient\\u200b,m)\n    - Postcondition (Post Post): ð‘šâˆˆð‘Žð‘Ÿð‘’ð‘ð‘–ð‘ð‘–ð‘’ð‘›ð‘¡.ð‘šð‘Žð‘–ð‘™ð‘ð‘œð‘¥ mâˆˆa recipient\\u200b.mailbox\n\n    Broadcast Messaging (ð‘€ð‘ð‘Ÿð‘œð‘Žð‘‘ð‘ð‘Žð‘ ð‘¡ð‘€broadcast\\u200b):\n    - Precondition (Pre Pre): âˆƒð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿâˆˆð´ âˆƒa sender\\u200bâˆˆA\n    - Action: ð‘ð‘Ÿð‘œð‘Žð‘‘ð‘ð‘Žð‘ ð‘¡ð‘€ð‘’ð‘ ð‘ ð‘Žð‘”ð‘’(ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ,ð‘š) broadcastMessage(a sender\\u200b,m)\n    - Postcondition (Post Post): âˆ€ð‘Žâˆˆð´âˆ–{ð‘Žð‘ ð‘’ð‘›ð‘‘ð‘’ð‘Ÿ},ð‘šâˆˆð‘Ž.ð‘šð‘Žð‘–ð‘™ð‘ð‘œð‘¥ âˆ€aâˆˆAâˆ–{a sender\\u200b},mâˆˆa.mailbox\n\n3. System Invariants and Domain Assertions\n    Invariant Preservation (ð¼ð‘ð‘Ÿð‘’ð‘ ð‘’ð‘Ÿð‘£ð‘’Ipreserve\\u200b):\n    - Invariant (ð¼ I): Î¦(ð´,ð‘€) Î¦(A,M)\n    - Upon Action (ð‘Žð‘ð‘¡ð‘–ð‘œð‘›action): ð‘Žð‘ð‘¡ð‘–ð‘œð‘›(ð´,ð‘€)â†’ð´â€²,ð‘€â€² action(A,M)â†’Aâ€²,Mâ€²\n    - Preservation (ð¼â€²Iâ€²): Î¦(ð´â€²,ð‘€â€²) Î¦(Aâ€²,Mâ€²)\n    Domain-Specific Logic Integration (ð·ð‘–ð‘›ð‘¡ð‘’ð‘”ð‘Ÿð‘Žð‘¡ð‘’Dintegrate\\u200b):\n    - Precondition (Pre ð· Pre D\\u200b): Î”(ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™) Î”(s global\\u200b)\n    - Action and Domain Logic: ð‘ð‘’ð‘Ÿð‘“ð‘œð‘Ÿð‘šð´ð‘ð‘¡ð‘–ð‘œð‘›ð‘Šð‘–ð‘¡â„Žð·ð‘œð‘šð‘Žð‘–ð‘›ð¿ð‘œð‘”ð‘–ð‘(ð‘Ž,ð‘š,Î”)â†’ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™â€²,Î”â€² performActionWithDomainLogic(a,m,Î”)â†’s globalâ€²\\u200b,Î”â€²\n    - Postcondition (Post ð· Post D\\u200b): Î”â€²(ð‘ ð‘”ð‘™ð‘œð‘ð‘Žð‘™â€²) Î”â€²(s globalâ€²\\u200b)\n\nImplementation Details:\nThe ServiceColony is implemented with a focus on modularity, scalability, and ease of use. It provides a high-level API for inhabitant management and message passing, abstracting away the complexities of asynchronous programming and inhabitant coordination. Developers can leverage the ServiceColony to build complex, responsive applications that are both computationally correct and domain-compliant.\n\nUsage:\nTo use the ServiceColony, instantiate it within your application and use its methods to create inhabitants and manage message passing. The system integrates seamlessly with the asyncio event loop, making it straightforward to incorporate into existing asynchronous applications.\n\nThe service_colony.py module, guided by the AMCN, provides a robust foundation for developing inhabitant-based systems within the RDDDY framework, ensuring that applications are built with a solid architectural foundation that promotes maintainability, scalability, and domain-driven design principles.\n\"\"\"\nimport asyncio\nimport json\nfrom typing import TYPE_CHECKING, Optional, TypeVar, cast\nfrom paho.mqtt import client as mclient\n\nimport reactivex as rx\nfrom loguru import logger\nfrom reactivex import operators as ops\nfrom reactivex.scheduler.eventloop import AsyncIOScheduler\n\nfrom dspygen.rdddy.base_message import BaseMessage, MessageFactory\n\nif TYPE_CHECKING:\n    from dspygen.rdddy.base_inhabitantimport BaseInhabitant\n\nT = TypeVar(\"T\", bound=\"BaseInhabitant\")\n\n\nclass ServiceColony:\n    \"\"\"Orchestrates inhabitant lifecycle management, message passing, and system-wide coordination within the RDDDY framework.\n\n    The ServiceColony class provides functionalities for creating, managing, and terminating inhabitants, facilitating asynchronous message passing between them, and maintaining system invariants.\n\n    Attributes:\n        inhabitants (dict): A dictionary containing inhabitant IDs as keys and corresponding inhabitant instances as values.\n        loop (asyncio.AbstractEventLoop): The asyncio event loop used for asynchronous operations.\n        scheduler (AsyncIOScheduler): An asynchronous scheduler for controlling task execution.\n        event_stream (Subject): A subject for publishing events within the inhabitant system.\n\n    Methods:\n        inhabitant_of(inhabitant_class, **kwargs): Creates a new inhabitant instance and starts its mailbox processing loop.\n        inhabitants_of(inhabitant_classes, **kwargs): Creates multiple inhabitant instances of different types.\n        publish(message): Publishes a message to the inhabitant system for distribution.\n        remove_inhabitant(inhabitant_id): Removes an inhabitant from the inhabitant system.\n        send(inhabitant_id, message): Sends a message to a specific inhabitant within the system.\n        wait_for_event(event_type): Waits for a specific event type to occur within the system.\n\n    Implementation Details:\n    The ServiceColony class implements inhabitant management and message passing functionalities, abstracting away the\n    complexities of asynchronous programming and inhabitant coordination. It integrates seamlessly with the asyncio\n    event loop, ensuring efficient concurrent operations.\n\n    Usage:\n    Instantiate an ServiceColony object within your application to manage inhabitants and coordinate message passing. Use its\n    methods to create inhabitants, send messages, and wait for specific events within the system.\n    \"\"\"\n\n    def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None, mqtt_client: mclient = None):\n        \"\"\"Initializes the ServiceColony.\n\n        Args:\n            loop (asyncio.AbstractEventLoop, optional): The asyncio event loop to be used for asynchronous operations.\n                If not provided, the default event loop will be used.\n\n        Attributes:\n            inhabitants (dict): A dictionary containing inhabitant IDs as keys and corresponding inhabitant instances as values.\n            loop (asyncio.AbstractEventLoop): The asyncio event loop used for asynchronous operations.\n            scheduler (AsyncIOScheduler): An asynchronous scheduler for controlling task execution.\n            event_stream (Subject): A subject for publishing events within the inhabitant system.\n        \"\"\"\n        self.mqtt_client = mqtt_client\n        self.inhabitants: dict[int, \"BaseInhabitant\"] = {}\n        self.loop = loop if loop is not None else asyncio.get_event_loop()\n        self.scheduler = AsyncIOScheduler(loop=self.loop)\n        self.event_stream = rx.subject.Subject()\n\n\n    def on_connect(self, client, userdata, flags, reason_code, properties):\n        print(\"Connected to MQTT Broker.\")\n        client.subscribe(\"service_colony/publish\")  # Subscribe to the topic\n\n    def on_message(self, client, userdata, msg):\n        print(f\"Received message from topic {msg.topic}: {msg.payload}\")\n        # Deserialize the message payload into your internal message format\n        payload_dict = json.loads(msg.payload)\n        message = MessageFactory.create_message(payload_dict) # Implement this method based on your message class\n        asyncio.run_coroutine_threadsafe(self.distribute_message(message), self.loop)\n\n    async def distribute_message(self, message):\n        # Prevent republishing to MQTT by directly invoking the local distribution logic\n        self.event_stream.on_next(message)\n        inhabitants = list(self.inhabitants.values())\n        for inhabitant in inhabitants:\n            await self.send(inhabitant.inhabitant_id, message)\n\n    async def inhabitant_of(self, inhabitant_class, **kwargs) -> T:\n        \"\"\"Creates a new inhabitant instance and starts its mailbox processing loop.\n        T = TypeVar(\"T\", bound=\"Actor\")\n\n        Preconditions (Pre):\n            - None\n\n        Transition (T):\n            - Creates a new instance of the specified inhabitant class.\n            - Initializes the inhabitant's mailbox.\n            - Starts the processing loop for the inhabitant's mailbox, enabling asynchronous message handling.\n\n        Postconditions (Post):\n            - A new inhabitant instance has been created and started successfully.\n\n        Args:\n            inhabitant_class: The class of the inhabitant to be created.\n            **kwargs: Additional keyword arguments to be passed to the inhabitant constructor.\n\n        Returns:\n            T: The created inhabitant instance.\n        \"\"\"\n        inhabitant = inhabitant_class(self, **kwargs)\n        self.inhabitants[inhabitant.inhabitant_id] = inhabitant\n        await inhabitant.start(self.scheduler)\n        logger.info(f\"Actor {inhabitant.inhabitant_id} started\")\n        return inhabitant\n\n    async def inhabitants_of(self, inhabitant_classes, **kwargs) -> list[T]:\n        \"\"\"Creates multiple inhabitant instances of different types and starts their mailbox processing loops.\n        T = TypeVar(\"T\", bound=\"Actor\")\n\n        Preconditions (Pre):\n            - None\n\n        Transition (T):\n            - Creates new instances of the specified inhabitant classes.\n            - Initializes the mailboxes for each inhabitant.\n            - Starts the processing loop for each inhabitant's mailbox, enabling asynchronous message handling.\n\n        Postconditions (Post):\n            - Multiple inhabitant instances have been created and started successfully.\n\n        Args:\n            inhabitant_classes (List[Type]): A list of inhabitant classes to be instantiated.\n            **kwargs: Additional keyword arguments to be passed to the inhabitant constructors.\n\n        Returns:\n            List[T]: A list containing the created inhabitant instances.\n        \"\"\"\n        inhabitants = []\n        for inhabitant_class in inhabitant_classes:\n            inhabitant = await self.inhabitant_of(inhabitant_class, **kwargs)\n            inhabitants.append(inhabitant)\n        return inhabitants\n\n    async def publish(self, message: \"BaseMessage\"):\n        \"\"\"Publishes a message to the inhabitant system for distribution.\n\n        Preconditions (Pre):\n            - None\n\n        Transition (T):\n            - Emits the message to the event stream of the inhabitant system.\n            - Sends the message to each inhabitant within the system for processing.\n\n        Postconditions (Post):\n            - The message has been published to the inhabitant system and processed by relevant inhabitants.\n            - If the message is an instance of the base Message class, an error is raised.\n\n        Args:\n            message (BaseMessage): The message to be published to the inhabitant system.\n\n        Raises:\n            ValueError: If the base Message class is used directly.\n        \"\"\"\n        logger.debug(f\"Publishing message: {message}\")\n\n        if type(message) is BaseMessage:\n            raise ValueError(\n                \"The base Message class should not be used directly. Please use a subclass of Message.\"\n            )\n\n        self.event_stream.on_next(message)\n        inhabitants = list(self.inhabitants.values())\n        for inhabitant in inhabitants:\n            await self.send(inhabitant.inhabitant_id, message)\n\n        service_colony_topic = \"service_colony/publish\"\n        # self.mqtt_client.publish(service_colony_topic, message.model_dump_json())\n\n    async def remove_inhabitant(self, inhabitant_id):\n        \"\"\"Removes an inhabitant from the inhabitant system.\n\n        Preconditions (Pre):\n            - The inhabitant ID must exist in the inhabitant system.\n\n        Transition (T):\n            - Removes the inhabitant with the specified ID from the inhabitant system.\n\n        Postconditions (Post):\n            - The inhabitant has been successfully removed from the inhabitant system.\n\n        Args:\n            inhabitant_id: The ID of the inhabitant to be removed.\n        \"\"\"\n        inhabitant = self.inhabitants.pop(inhabitant_id, None)\n        if inhabitant:\n            logger.debug(f\"Removing inhabitant {inhabitant_id}\")\n        else:\n            logger.debug(f\"Actor {inhabitant_id} not found for removal\")\n        logger.debug(f\"Current inhabitants count: {len(self.inhabitants)}\")\n\n    async def send(self, inhabitant_id: int, message: \"BaseMessage\"):\n        \"\"\"Sends a message to a specific inhabitant within the inhabitant system.\n\n        Preconditions (Pre):\n            - The inhabitant ID must exist in the inhabitant system.\n            - The message must be an instance of the Message class.\n\n        Transition (T):\n            - Delivers the message to the specified inhabitant's mailbox for processing.\n\n        Postconditions (Post):\n            - The message has been successfully sent to the specified inhabitant for processing.\n\n        Args:\n            inhabitant_id (int): The ID of the target inhabitant.\n            message (BaseMessage): The message to be sent to the target inhabitant.\n        \"\"\"\n        # logger.debug(f\"Sending message {message} to inhabitant {inhabitant_id}\")\n        inhabitant = self.inhabitants.get(inhabitant_id)\n        if inhabitant:\n            inhabitant.mailbox.on_next(message)\n            await asyncio.sleep(0)\n        else:\n            logger.debug(f\"Actor {inhabitant_id} not found.\")\n\n    async def wait_for_message(self, message_type: type) -> \"BaseMessage\":\n        \"\"\"Waits for a message of a specific type to be published to the inhabitant system.\n\n        Preconditions (Pre):\n            - None\n\n        Transition (T):\n            - Subscribes to the event stream of the inhabitant system.\n            - Waits until a message of the specified type is published.\n\n        Postconditions (Post):\n            - A message of the specified type has been received from the inhabitant system.\n\n        Args:\n            message_type (type): The type of message to wait for.\n\n        Returns:\n            asyncio.Future: A future object representing the awaited message.\n        \"\"\"\n        loop = asyncio.get_event_loop()\n        future = loop.create_future()\n\n        def on_next(msg):\n            if isinstance(msg, message_type):\n                future.set_result(msg)\n                subscription.dispose()\n\n        subscription = self.event_stream.pipe(\n            ops.filter(lambda msg: isinstance(msg, message_type))\n        ).subscribe(on_next)\n\n        return await future\n\n    def __getitem__(self, inhabitant_id) -> T:\n        \"\"\"Retrieves an inhabitant by its ID from the inhabitant system.\n\n        Preconditions (Pre):\n            - The inhabitant ID must exist in the inhabitant system.\n\n        Transition (T):\n            - Retrieves the inhabitant with the specified ID from the inhabitant system.\n\n        Postconditions (Post):\n            - The inhabitant with the specified ID has been successfully retrieved from the inhabitant system.\n\n        Args:\n            inhabitant_id: The ID of the inhabitant to retrieve.\n\n        Returns:\n            BaseInhabitant: The inhabitant object corresponding to the specified ID.\n        \"\"\"\n        return cast(T, self.inhabitants.get(inhabitant_id))\n\n\n    async def shutdown(self):\n        \"\"\"Shuts down the inhabitant system and terminates all inhabitants.\n\n        Preconditions (Pre):\n            - None\n\n        Transition (T):\n            - Terminates all inhabitants within the inhabitant system.\n            - Closes the event stream and scheduler.\n\n        Postconditions (Post):\n            - The inhabitant system has been successfully shut down.\n        \"\"\"\n        # self.mqtt_client.loop_stop()\n        # self.mqtt_client.disconnect()\n        logger.debug(\"Actor system shutdown complete.\")\n\n\nimport asyncio\n\n\nasync def main():\n    print(\"main\")\n    # await\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n"
        }
    ]
}